/** Parses HH:MM:SS time string into seconds from midnight. */
function parseTimeToSeconds(timeString) { if (!timeString || typeof timeString !== 'string') return null; const parts = timeString.split(':'); if (parts.length === 3) { const h = parseInt(parts[0], 10); const m = parseInt(parts[1], 10); const s = parseInt(parts[2], 10); if (!isNaN(h) && !isNaN(m) && !isNaN(s)) { return h * 3600 + m * 60 + s; } } return null; }

/** Formats total seconds into MM:SS format. */
function formatSecondsToMMSS(totalSeconds) { if (totalSeconds === null || totalSeconds < 0 || isNaN(totalSeconds)) { return "--:--"; } const minutes = Math.floor(totalSeconds / 60); const seconds = Math.floor(totalSeconds % 60); const paddedMinutes = String(minutes).padStart(2, '0'); const paddedSeconds = String(seconds).padStart(2, '0'); return `${paddedMinutes}:${paddedSeconds}`; }

/** Calculates statistics for a single game from its detailed data object. */
function calculateGameStats(matchDetail) {
    if (!matchDetail?.match?.events || !matchDetail?.match?.lineups) { console.error("calculateGameStats ERROR: Invalid match detail structure", matchDetail); return null; }
    const match = matchDetail.match;
    console.log(`--> Calculating stats for match ID: ${match.match_id}`);
    const gameStats = {
        matchId: match.match_id, date: match.date,
        teamAInfo: { id: match.team_A_id, name: match.team_A_name, score: match.fs_A, timeouts: 0, subs: 0, impliedOpponentErrors: 0, impliedErrorsMade: 0 },
        teamBInfo: { id: match.team_B_id, name: match.team_B_name, score: match.fs_B, timeouts: 0, subs: 0, impliedOpponentErrors: 0, impliedErrorsMade: 0 },
        playerStats: {}
    };
    const substitutionLog = match.substitution_events && match.substitution_events.length > 0 ? match.substitution_events : (match.events || []).filter(e => e.code === 'vaihto');
    const playerSetParticipation = {};
    let lineupIsValid = true;
    match.lineups.forEach(p => { const playerIdStr = String(p.player_id); if (playerIdStr && p.team_id && p.player_name && p.shirt_number !== undefined) { gameStats.playerStats[playerIdStr] = { name: p.player_name, shirt: p.shirt_number, team: p.team_id === gameStats.teamAInfo.id ? 'A' : 'B', points: 0, serves: 0, isCaptain: p.captain === 'C', setsPlayedFully: 0 }; playerSetParticipation[playerIdStr] = { started: new Set(), subbedIn: new Set(), subbedOut: new Set() }; if (p.playing_position) { for (const setNumStr in p.playing_position) { const setNum = parseInt(setNumStr, 10); if (!isNaN(setNum) && p.playing_position[setNum] >= 1 && p.playing_position[setNum] <= 6) { playerSetParticipation[playerIdStr].started.add(setNum); } } } } else { console.warn(`Skipping invalid lineup entry in match ${gameStats.matchId}:`, p); if (!playerIdStr) lineupIsValid = false; } });
    if (!lineupIsValid) { console.error(`Calculation failed for match ${gameStats.matchId}: Invalid lineup entries found.`); return null; }
    substitutionLog.forEach(sub => { const period = parseInt(sub.period, 10); if (!isNaN(period) && period > 0) { const playerInId = String(sub.player_id); const playerOutId = String(sub.player_2_id); if (playerInId && playerSetParticipation[playerInId]) { playerSetParticipation[playerInId].subbedIn.add(period); } if (playerOutId && playerSetParticipation[playerOutId]) { playerSetParticipation[playerOutId].subbedOut.add(period); } } });
    const maxSetPlayed = Math.max(1, ...match.events.map(e => parseInt(e.period, 10)).filter(p => !isNaN(p) && p > 0));
    for (const playerId in playerSetParticipation) { let fullSetsCount = 0; for (let setNum = 1; setNum <= maxSetPlayed; setNum++) { const participation = playerSetParticipation[playerId]; if (participation.started.has(setNum) && !participation.subbedOut.has(setNum) && !participation.subbedIn.has(setNum)) { fullSetsCount++; } } if (gameStats.playerStats[playerId]) { gameStats.playerStats[playerId].setsPlayedFully = fullSetsCount; } }
    (match.events || []).forEach(event => { if (event.code === 'aikalisa') { if (event.team_id === gameStats.teamAInfo.id) gameStats.teamAInfo.timeouts++; else if (event.team_id === gameStats.teamBInfo.id) gameStats.teamBInfo.timeouts++; } });
    substitutionLog.forEach(sub => { if (sub.team_id === gameStats.teamAInfo.id) gameStats.teamAInfo.subs++; else if (sub.team_id === gameStats.teamBInfo.id) gameStats.teamBInfo.subs++; });
    let currentSet = 0; let teamAPoints = 0; let teamBPoints = 0; let servingTeam = null; let lastServingTeam = null; let playerPositionsA = {}; let playerPositionsB = {};
    const setGameStartingLineup = (setNum) => { playerPositionsA = {}; playerPositionsB = {}; match.lineups.forEach(p => { const pid = String(p.player_id); if (p.playing_position?.[setNum]) { const zone = p.playing_position[setNum]; if (zone >= 1 && zone <= 6) { if (p.team_id === gameStats.teamAInfo.id) playerPositionsA[zone] = pid; else playerPositionsB[zone] = pid; } } }); };
    const rotateGameTeam = (teamIdSymbol) => { const currentPositions = teamIdSymbol === 'A' ? playerPositionsA : playerPositionsB; const newPositions = {}; newPositions[1] = currentPositions[2]; newPositions[6] = currentPositions[1]; newPositions[5] = currentPositions[6]; newPositions[4] = currentPositions[5]; newPositions[3] = currentPositions[4]; newPositions[2] = currentPositions[3]; for (let zone = 1; zone <= 6; zone++) { if (teamIdSymbol === 'A') playerPositionsA[zone] = newPositions[zone] || null; else playerPositionsB[zone] = newPositions[zone] || null; } };
    const sortedGameEvents = [...match.events].sort((a, b) => { if (!a.wall_time || !b.wall_time) return 0; if (a.wall_time < b.wall_time) return -1; if (a.wall_time > b.wall_time) return 1; return 0; });
    let eventProcessingError = false;
    for (const event of sortedGameEvents) { try { let needsRotation = null; let pointScoredBy = null; let scorerPlayerId = null; if (event.period && parseInt(event.period) > 0 && parseInt(event.period) !== currentSet) { if (event.code !== 'maali') { currentSet = parseInt(event.period); teamAPoints = 0; teamBPoints = 0; setGameStartingLineup(currentSet); } }
        switch (event.code) { case 'aloitajakso': currentSet = parseInt(event.period); teamAPoints = 0; teamBPoints = 0; setGameStartingLineup(currentSet); servingTeam = null; lastServingTeam = null; break; case 'aloittavajoukkue': servingTeam = event.team_id === gameStats.teamAInfo.id ? 'A' : 'B'; lastServingTeam = servingTeam; const serverIdStart = servingTeam === 'A' ? playerPositionsA[1] : playerPositionsB[1]; if (serverIdStart && gameStats.playerStats[serverIdStart]) { gameStats.playerStats[serverIdStart].serves++; } break; case 'piste': const scoreMatch = event.description?.match(/(\d+)-(\d+)/); if (scoreMatch) { const currentPtsA = teamAPoints; const currentPtsB = teamBPoints; const newPtsA = parseInt(scoreMatch[1]); const newPtsB = parseInt(scoreMatch[2]); pointScoredBy = (newPtsA > currentPtsA) ? 'A' : 'B'; teamAPoints = newPtsA; teamBPoints = newPtsB; if (event.player_id && String(event.player_id) !== '1') { scorerPlayerId = String(event.player_id); if(gameStats.playerStats[scorerPlayerId]) { gameStats.playerStats[scorerPlayerId].points++; } else { console.warn(`Scorer ID ${scorerPlayerId} from event not in lineup for match ${gameStats.matchId}`); } } else { if (pointScoredBy === 'A') gameStats.teamAInfo.impliedOpponentErrors++; else gameStats.teamBInfo.impliedOpponentErrors++; } if (servingTeam && pointScoredBy !== servingTeam) { needsRotation = pointScoredBy; } servingTeam = pointScoredBy; if (lastServingTeam === servingTeam && lastServingTeam !== null) { const serverIdHold = servingTeam === 'A' ? playerPositionsA[1] : playerPositionsB[1]; if (serverIdHold && gameStats.playerStats[serverIdHold]) { gameStats.playerStats[serverIdHold].serves++; } } lastServingTeam = servingTeam; } else { console.warn(`Could not parse score from piste event description: ${event.description}`); } break; case 'maali': servingTeam = null; lastServingTeam = null; break; case 'lopetaottelu': servingTeam = null; lastServingTeam = null; break; }
        if (needsRotation) { rotateGameTeam(needsRotation); const serverIdRotated = needsRotation === 'A' ? playerPositionsA[1] : playerPositionsB[1]; if (serverIdRotated && gameStats.playerStats[serverIdRotated]) { gameStats.playerStats[serverIdRotated].serves++; } } } catch (innerError) { console.error(`Error processing event ${event.event_id} in match ${gameStats.matchId}:`, innerError); eventProcessingError = true; } }
    if (eventProcessingError) { console.warn(`Stats for match ${gameStats.matchId} may be incomplete due to event processing errors.`); }
    gameStats.teamAInfo.impliedErrorsMade = gameStats.teamBInfo.impliedOpponentErrors; gameStats.teamBInfo.impliedErrorsMade = gameStats.teamAInfo.impliedOpponentErrors;
    console.log(`Finished calculating stats for match ID: ${match.match_id}`);
    console.log(`Returning gameStats for match ${match.match_id}:`, JSON.parse(JSON.stringify(gameStats))); // Log final calculated object
    return gameStats;
}

// --- Aggregate Stats Function ---
/** Adds stats from a single game to the aggregate totals object. */
function aggregateGameStats(gameStats) { if (!gameStats || !teamIdOfInterest) return; if (!aggregateStats.players) { aggregateStats = { players: {}, team: { timeouts: 0, subs: 0, impliedOpponentErrors: 0, impliedErrorsMade: 0, gamesProcessed: 0 } }; } let teamOfInterestSymbol = null; if (String(gameStats.teamAInfo.id) === String(teamIdOfInterest)) teamOfInterestSymbol = 'A'; else if (String(gameStats.teamBInfo.id) === String(teamIdOfInterest)) teamOfInterestSymbol = 'B'; else return; const teamData = gameStats[`team${teamOfInterestSymbol}Info`]; aggregateStats.team.timeouts += teamData.timeouts; aggregateStats.team.subs += teamData.subs; aggregateStats.team.impliedOpponentErrors += teamData.impliedOpponentErrors; aggregateStats.team.impliedErrorsMade += teamData.impliedErrorsMade; aggregateStats.team.gamesProcessed++; for (const playerId in gameStats.playerStats) { const pStats = gameStats.playerStats[playerId]; if (pStats.team === teamOfInterestSymbol) { if (!aggregateStats.players[playerId]) { aggregateStats.players[playerId] = { name: pStats.name, shirt: pStats.shirt, points: 0, serves: 0, gamesPlayed: 0, setsPlayedFully: 0, isCaptain: pStats.isCaptain }; } else if (pStats.isCaptain) { aggregateStats.players[playerId].isCaptain = true; } aggregateStats.players[playerId].points += pStats.points; aggregateStats.players[playerId].serves += pStats.serves; aggregateStats.players[playerId].setsPlayedFully += pStats.setsPlayedFully; aggregateStats.players[playerId].gamesPlayed++; } } }
