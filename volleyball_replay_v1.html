<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volleyball Replay</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for court and players */
        .court-side {
            transition: background-color 0.2s ease-in-out;
            position: relative;
        }
        .court-zone {
            border: 1px solid #9ca3af; /* gray-400 */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            min-height: 80px;
        }
        .player-marker {
            width: 40px; /* Increased width slightly */
            height: 45px; /* Increased height for name */
            border-radius: 8px; /* Slightly less round for more space */
            background-color: #3b82f6; /* blue-500 */
            color: white;
            display: flex;
            flex-direction: column; /* Stack number and name vertically */
            justify-content: center;
            align-items: center;
            font-weight: bold;
            position: absolute;
            border: 1px solid white;
            transition: all 0.3s ease-in-out;
            z-index: 10;
            padding-top: 2px; /* Small padding for number */
            box-sizing: border-box; /* Ensure padding/border are within width/height */
        }
        .player-marker .shirt-number { /* New class for the number span */
            font-size: 0.9rem; /* Existing font-size for number */
            line-height: 1;
        }
        .player-marker .player-name-on-marker { /* New class for the name span */
            font-size: 0.65rem; /* Smaller font for the name */
            font-weight: normal;
            line-height: 1;
            margin-top: 2px;
            text-align: center;
            white-space: nowrap; /* Prevent name from wrapping if too long */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ellipsis if name is still too long */
            max-width: 38px; /* Ensure it doesn't overflow marker width */
        }
        .player-marker.team-b {
            background-color: #ef4444; /* red-500 */
        }
        .player-marker.serving {
            border: 3px solid #facc15; /* yellow-400 */
            box-shadow: 0 0 8px #fde047; /* yellow-300 glow */
        }
        .player-marker.point-scorer {
            background-color: #16a34a; /* green-600 */
            border: 3px solid #86efac; /* green-300 */
            box-shadow: 0 0 15px 5px #4ade80; /* green-400 glow */
            transform: scale(1.2);
        }
        .court-side.lost-point-highlight {
             background-color: rgba(248, 113, 113, 0.2); /* Light red transparent flash */
        }
        .net {
            background-color: #6b7280; /* gray-500 */
        }
        table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        th, td { border: 1px solid #d1d5db; padding: 0.5rem; text-align: left; font-size: 0.875rem; /* text-sm */ }
        th { background-color: #f3f4f6; font-weight: 600; /* semibold */ }
        .summary-row td { font-style: italic; color: #4b5563; background-color: #f9fafb; /* gray-50 */}
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        /* Status message styles */
        .status-loading { color: #2563eb; /* blue-600 */ }
        .status-error { color: #dc2626; /* red-600 */ }
        .status-success { color: #16a34a; /* green-600 */ }
        /* Match list item style */
        .match-list-item {
            padding: 0.5rem;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 0.375rem; /* rounded-md */
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .match-list-item:hover {
            background-color: #f9fafb; /* gray-50 */
        }
        .match-list-item.played {
            border-left: 4px solid #16a34a; /* green-600 */
        }
        .match-list-item.not-played {
            border-left: 4px solid #f59e0b; /* amber-500 */
            opacity: 0.7;
        }
        /* Rally duration chart styles */
        .rally-chart-visualization { /* Generic class for chart containers */
            overflow-x: auto; /* Enable horizontal scrolling for the chart */
            overflow-y: hidden;
            padding-bottom: 10px; /* Space for scrollbar if it appears */
            position: relative; /* For positioning Y-axis elements if needed */
        }
        .y-axis-label {
            font-size: 10px;
            fill: #4b5563; /* gray-600 */
            text-anchor: end;
        }
        .y-axis-line {
            stroke: #d1d5db; /* gray-300 */
            stroke-width: 1;
            stroke-dasharray: 2,2; /* Dashed line for grid */
        }
        /* Rally Stats Summary Table & Advanced Stats Tables */
        #rally-stats-summary-table th, #rally-stats-summary-table td,
        #player-scored-rally-stats-table th, #player-scored-rally-stats-table td,
        .advanced-stats-table th, .advanced-stats-table td { /* Apply to all stats tables */
            padding: 0.3rem 0.5rem;
            font-size: 0.8rem;
        }
        .advanced-stats-section h5 {
            font-size: 1rem; /* text-base */
            font-weight: 600; /* semibold */
            color: #374151; /* gray-700 */
            margin-top: 0.75rem; /* mt-3 */
            margin-bottom: 0.5rem; /* mb-2 */
            padding-bottom: 0.25rem; /* pb-1 */
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
        }
        #main-content-container {
            position: relative;
        }
        /* Tooltip for serving streak court layout */
        #streak-court-tooltip {
            display: none;
            position: absolute;
            background-color: #f9fafb; /* gray-50 */
            border: 1px solid #9ca3af; /* gray-400 */
            border-radius: 8px;
            padding: 0.75rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            pointer-events: none; /* So the tooltip itself doesn't block mouse events */
            width: 320px;
            transition: opacity 0.1s ease-in-out;
        }
        #streak-court-tooltip.visible {
            display: block;
        }
        #streak-court-tooltip-content {
            /* container for the court inside the tooltip */
        }
        #streak-court-tooltip .court-container {
             border: 1px solid #d1d5db; /* gray-300 */
        }
        #streak-court-tooltip .court-side {
            width: 50%;
        }
        #streak-court-tooltip .court-zone {
            min-height: 40px; /* Smaller zones for the tooltip */
            font-size: 0.7rem;
        }
        #streak-court-tooltip .player-marker {
            width: 32px;
            height: 36px;
            border-radius: 4px;
        }
         #streak-court-tooltip .player-marker .shirt-number {
            font-size: 0.75rem;
        }
        #streak-court-tooltip .player-marker .player-name-on-marker {
            font-size: 0.5rem;
        }
         #streak-court-tooltip .net {
            background-color: #6b7280; /* gray-500 */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans p-4 md:p-8">

    <div id="main-content-container" class="container mx-auto max-w-4xl bg-white p-6 rounded-lg shadow-lg">

        <h1 class="text-2xl font-bold text-center mb-6 text-gray-800">Volleyball Game Replay</h1>

        <div class="mb-6 p-4 border border-gray-300 rounded-md bg-gray-50">
            <h2 class="text-lg font-semibold text-gray-700 mb-2">Load Team's Games</h2>
            <label for="team-matches-url" class="block text-sm font-medium text-gray-700 mb-1">Team Matches URL (getMatches?team_id=...):</label>
            <div class="flex space-x-2">
                <input type="text" id="team-matches-url" class="flex-grow p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="Paste team matches URL here">
                <button id="load-team-matches-btn" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-md transition duration-150 ease-in-out whitespace-nowrap">
                    Load Team Matches
                </button>
            </div>
            <div id="team-load-status" class="mt-2 text-sm h-5"></div>
        </div>

        <div id="match-list-display-area" class="mb-6">
            </div>

        <div class="mb-4 p-4 border border-gray-300 rounded-md bg-gray-50">
            <h2 class="text-lg font-semibold text-gray-700 mb-2">Load Single Game by URL</h2>
            <label for="game-url" class="block text-sm font-medium text-gray-700 mb-1">Specific Game Data URL (getMatch?match_id=...):</label>
            <div class="flex space-x-2">
                <input type="text" id="game-url" class="flex-grow p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="Paste specific game data URL here or select from list above">
                <button id="load-data-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition duration-150 ease-in-out">
                    Load Game
                </button>
            </div>
            <div id="load-status" class="mt-2 text-sm h-5"></div>
        </div>


        <div id="replay-ui-container" class="opacity-50">
            <div id="scoreboard" class="text-center text-xl font-semibold mb-2 p-3 bg-gray-200 rounded-md text-gray-700">
                Set <span id="set-number">-</span> |
                <span id="team-a-name">Team A</span> <span id="team-a-points">0</span> -
                <span id="team-b-points">0</span> <span id="team-b-name">Team B</span> |
                Sets: <span id="team-a-sets">0</span> - <span id="team-b-sets">0</span>
            </div>

            <div id="match-info" class="text-xs text-center text-gray-600 mb-4 border-t border-b py-1">
                <span id="match-date">Date</span> @ <span id="match-time">Time</span> |
                Venue: <span id="match-venue">Venue</span> |
                Referee: <span id="match-referee">Referee</span> |
                Attendance: <span id="match-attendance">0</span> |
                Set Time: <span id="set-elapsed-time">--:--</span>
            </div>


            <div class="flex items-stretch justify-center mb-4" id="court-area">
                <div id="court-side-a" class="court-side w-1/2 grid grid-cols-2 grid-rows-3">
                    <div id="zone-a-5" class="court-zone"></div> <div id="zone-a-4" class="court-zone"></div>
                    <div id="zone-a-6" class="court-zone"></div> <div id="zone-a-3" class="court-zone"></div>
                    <div id="zone-a-1" class="court-zone"></div> <div id="zone-a-2" class="court-zone"></div>
                </div>
                <div class="net w-1 mx-0"></div>
                <div id="court-side-b" class="court-side w-1/2 grid grid-cols-2 grid-rows-3">
                     <div id="zone-b-2" class="court-zone"></div> <div id="zone-b-1" class="court-zone"></div>
                     <div id="zone-b-3" class="court-zone"></div> <div id="zone-b-6" class="court-zone"></div>
                     <div id="zone-b-4" class="court-zone"></div> <div id="zone-b-5" class="court-zone"></div>
                </div>
            </div>

            <!-- Playback controls moved directly under the court for better UX -->
            <div class="text-center my-4 space-x-2" aria-label="Playback controls">
                <button id="prev-event" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out" disabled>
                    Previous Event
                </button>
                <button id="play-pause-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out w-24" disabled>
                    Play
                </button>
                <button id="next-event" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out" disabled>
                    Next Event
                </button>
                <button id="skip-to-end-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out" disabled>
                    Skip to End
                </button>
            </div>
            <div id="all-rallies-duration-chart-area" class="mt-8 mb-2 opacity-50">
                <h3 class="text-xl font-semibold mb-3 text-center text-gray-700">All Rallies: Durations (seconds)</h3>
                <div id="all-rallies-duration-visualization" class="rally-chart-visualization p-4 border border-gray-300 rounded-md bg-gray-50 min-h-[280px]">
                    <p class="text-center text-gray-500">Rally duration chart will appear here once a game is loaded.</p>
                </div>
            </div>

            <div id="rally-stats-summary-area" class="mt-0 mb-2 opacity-50">
                 <h4 class="text-lg font-semibold mb-2 text-center text-gray-600">All Rallies: Length Analysis</h4>
                 <div id="rally-stats-summary-content" class="p-3 border border-gray-200 rounded-md bg-gray-50 text-sm">
                     <p class="text-center text-gray-500">Rally statistics will appear here.</p>
                 </div>
            </div>

            <div id="player-scored-rallies-duration-chart-area" class="mt-4 mb-2 opacity-50"> <h3 class="text-xl font-semibold mb-3 text-center text-gray-700">Player-Scored Rallies: Durations (seconds)</h3>
                <div id="player-scored-rallies-duration-visualization" class="rally-chart-visualization p-4 border border-gray-300 rounded-md bg-gray-50 min-h-[280px]">
                    <p class="text-center text-gray-500">Player-scored rally duration chart will appear here.</p>
                </div>
            </div>

            <div id="player-scored-rally-stats-summary-area" class="mt-0 mb-6 opacity-50">
                 <h4 class="text-lg font-semibold mb-2 text-center text-gray-600">Player-Scored Rallies: Length Analysis</h4>
                 <div id="player-scored-rally-stats-summary-content" class="p-3 border border-gray-200 rounded-md bg-gray-50 text-sm">
                     <p class="text-center text-gray-500">Statistics for rallies scored by a specific player will appear here.</p>
                 </div>
            </div>


            <div id="event-description" class="text-center text-lg italic text-gray-600 mb-4 h-6">
                Load game data using the URL field above or select from a team's match list.
            </div>

            <div class="text-center mb-6 space-x-2">
                <button id="prev-event" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out" disabled>
                    Previous Event
                </button>
                 <button id="play-pause-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out w-24" disabled>
                    Play
                </button>
                <button id="next-event" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out" disabled>
                    Next Event
                </button>
                 <button id="skip-to-end-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out" disabled>
                    Skip to End
                </button>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="stats-area">
                <div>
                    <h3 id="stats-team-a-name" class="text-lg font-semibold mb-2 text-center">Team A Stats</h3>
                    <table id="stats-team-a">
                        <thead>
                            <tr><th>#</th><th>Name</th><th>Points</th><th>Serves</th></tr>
                        </thead>
                        <tbody></tbody>
                        <tfoot></tfoot>
                    </table>
                </div>
                <div>
                    <h3 id="stats-team-b-name" class="text-lg font-semibold mb-2 text-center">Team B Stats</h3>
                    <table id="stats-team-b">
                         <thead>
                             <tr><th>#</th><th>Name</th><th>Points</th><th>Serves</th></tr>
                        </thead>
                        <tbody></tbody>
                        <tfoot></tfoot>
                    </table>
                </div>
            </div>
        </div>
        <div class="mt-8 text-center">
            <button id="toggle-advanced-stats-btn" class="bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out" disabled>
                Show Advanced Game Statistics
            </button>
        </div>

        <div id="advanced-stats-container" class="mt-6 border-t border-gray-300 pt-4" style="display: none;">
            <h2 class="text-xl font-bold text-center mb-4 text-gray-800">Advanced Game Statistics</h2>

            <div id="advanced-set-summaries-section" class="advanced-stats-section mb-6">
                <h5>Set Summaries</h5>
                <div id="advanced-set-summaries-content"><p class="text-gray-400 italic text-center">Data will appear here.</p></div>
            </div>

            <div id="advanced-sideout-section" class="advanced-stats-section mb-6">
                <h5>Overall Side-Out Percentages</h5>
                <div id="advanced-sideout-content"><p class="text-gray-400 italic text-center">Data will appear here.</p></div>
            </div>

            <div id="advanced-pointruns-section" class="advanced-stats-section mb-6">
                <h5>Longest Point Runs</h5>
                <div id="advanced-pointruns-content"><p class="text-gray-400 italic text-center">Data will appear here.</p></div>
            </div>

            <div id="advanced-player-points-set-section" class="advanced-stats-section mb-6">
                <h5>Player Points Per Set</h5>
                <div id="advanced-player-points-set-content"><p class="text-gray-400 italic text-center">Data will appear here.</p></div>
            </div>
            <div id="advanced-starting-positions-section" class="advanced-stats-section mb-6">
                <h5>Starting Positions by Set</h5>
                <div id="advanced-starting-positions-content"><p class="text-gray-400 italic text-center">Data will appear here.</p></div>
            </div>
            <div id="advanced-leadchanges-maxleads-section" class="advanced-stats-section mb-6">
                <h5>Lead Changes & Max Leads Per Set</h5>
                <div id="advanced-leadchanges-maxleads-content"><p class="text-gray-400 italic text-center">Data will appear here.</p></div>
            </div>
            <div id="advanced-timeout-performance-section" class="advanced-stats-section mb-6">
                <h5>Performance After Timeouts</h5>
                <div id="advanced-timeout-performance-content"><p class="text-gray-400 italic text-center">Data will appear here.</p></div>
            </div>
            <div id="advanced-serving-streaks-section" class="advanced-stats-section mb-6">
                <h5>Longest Serving Streaks (Team Points)</h5>
                <div id="advanced-serving-streaks-content"><p class="text-gray-400 italic text-center">Data will appear here.</p></div>
            </div>
            <div id="advanced-serve-receive-points-section" class="advanced-stats-section mb-6">
                <h5>Points on Serve / Reception</h5>
                <div id="advanced-serve-receive-points-content"><p class="text-gray-400 italic text-center">Data will appear here.</p></div>
            </div>
             <div id="advanced-avg-points-service-turn-section" class="advanced-stats-section mb-6">
                <h5>Average Points per Service Turn</h5>
                <div id="advanced-avg-points-service-turn-content"><p class="text-gray-400 italic text-center">Data will appear here.</p></div>
            </div>
            <div id="advanced-rotational-performance-section" class="advanced-stats-section mb-6">
                <h5>Rotational Performance (Point Differential)</h5>
                <div id="advanced-rotational-performance-content"><p class="text-gray-400 italic text-center">Data will appear here.</p></div>
            </div>
        </div>

        <div id="ai-analysis-container" class="mt-6 border-t border-gray-300 pt-4" style="display: none;">
            <h2 class="text-xl font-bold text-center mb-4 text-gray-800">AI-Powered Game Analysis</h2>

            <div class="mb-6 p-4 border border-gray-300 rounded-md bg-gray-50">
                <label for="openrouter-api-key" class="block text-sm font-medium text-gray-700 mb-1">OpenRouter.ai API Key:</label>
                <div class="flex space-x-2">
                    <input type="password" id="openrouter-api-key" class="flex-grow p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="Enter your OpenRouter.ai API key here">
                    <button id="generate-ai-analysis-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md transition duration-150 ease-in-out whitespace-nowrap" disabled>
                        Generate Analysis
                    </button>
                </div>
                 <div class="mt-2 text-xs text-gray-500">
                    Your key is saved in your browser's local storage and is never sent to our servers. Get a key from <a href="https://openrouter.ai/" target="_blank" class="text-indigo-600 hover:underline">OpenRouter.ai</a>.
                </div>
                <div id="ai-analysis-status" class="mt-2 text-sm h-5"></div>
            </div>

            <div id="ai-analysis-output-area" class="p-4 border border-gray-200 rounded-md bg-gray-50 min-h-[150px]">
                <p class="text-center text-gray-500">AI analysis will appear here.</p>
            </div>
        </div>

        <!-- Tooltip for Serving Streak Court Layout -->
        <div id="streak-court-tooltip">
            <h6 class="text-xs font-bold text-center mb-1 text-gray-700">Court State at Start of Streak</h6>
            <div id="streak-court-tooltip-content" class="flex items-stretch justify-center">
                <!-- Mini-court will be rendered here by JS -->
            </div>
        </div>

    </div>
    <script type="module">
    import { calculateGameStats, parseTimeToSeconds, formatSecondsToMMSS, calculateServingStreaks, calculateRotationalStats } from './js/stats_calculator.js';

        // --- APPLICATION LOGIC ---
        const API_BASE_URL = "https://lentopallo-api.torneopal.net/taso/rest/";
        const ALLOWED_HOSTNAME = "lentopallo-api.torneopal.net";
        const playbackSpeed = 1500;

        // Network helper: try direct fetch, then local proxy (if localhost), then a list of public proxies.
        async function fetchWithFallback(targetUrl, options = {}) {
            const { preferLocalRaw = false, timeoutMs = 10000 } = options;
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), timeoutMs);
            // Helper to attempt fetch and parse JSON (or throw)
            async function tryFetch(u, parseAsAllorigins = false, parseAsThingproxy = false) {
                try {
                    const resp = await fetch(u, { signal: controller.signal });
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    const txt = await resp.text();
                    // If caller expects allorigins format, parse wrapper
                    if (parseAsAllorigins) {
                        try { const wrapper = JSON.parse(txt); if (wrapper && wrapper.contents) return JSON.parse(wrapper.contents); } catch (e) { throw new Error('Failed to parse allorigins response'); }
                    }
                    // thingproxy returns raw proxied body; try parse
                    if (parseAsThingproxy) {
                        try { return JSON.parse(txt); } catch (e) { throw new Error('Failed to parse thingproxy response'); }
                    }
                    // Default: try JSON.parse, otherwise return text as-is
                    try { return JSON.parse(txt); } catch (e) { return txt; }
                } catch (err) {
                    throw err;
                }
            }

            try {
                // 1) Direct
                try {
                    const result = await tryFetch(targetUrl);
                    clearTimeout(timeout);
                    return result;
                } catch (directErr) {
                    console.debug('Direct fetch failed, will try proxies:', directErr.message);
                }

                // 2) Local proxy when running on localhost
                try {
                    const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                    if (isLocal) {
                        const localUrl = preferLocalRaw ? `/proxy/raw?url=${encodeURIComponent(targetUrl)}` : `/proxy/get?url=${encodeURIComponent(targetUrl)}`;
                        const resp = await fetch(localUrl, { signal: controller.signal });
                        if (!resp.ok) throw new Error(`Local proxy HTTP ${resp.status}`);
                        if (preferLocalRaw) {
                            const parsed = await resp.json(); clearTimeout(timeout); return parsed;
                        } else {
                            const wrapper = await resp.json(); clearTimeout(timeout); return JSON.parse(wrapper.contents);
                        }
                    }
                } catch (localErr) {
                    console.debug('Local proxy attempt failed:', localErr.message);
                }

                // 3) Public proxies (try a few endpoints)
                const publicProxies = [
                    { url: (u) => `https://api.allorigins.win/get?url=${encodeURIComponent(u)}`, parseAllorigins: true },
                    { url: (u) => `https://thingproxy.freeboard.io/fetch/${u}`, parseThingproxy: true }
                ];
                for (const p of publicProxies) {
                    try {
                        const proxyUrl = p.url(targetUrl);
                        const result = await tryFetch(proxyUrl, p.parseAllorigins, p.parseThingproxy);
                        clearTimeout(timeout);
                        return result;
                    } catch (proxyErr) {
                        console.debug(`Public proxy ${p.url.name || 'proxy'} failed:`, proxyErr.message);
                    }
                }

                throw new Error('All network attempts failed');
            } finally {
                clearTimeout(timeout);
            }
        }

        let teamMatchesUrlInput, loadTeamMatchesBtn, teamLoadStatusEl, matchListDisplayAreaEl,
            gameUrlInput, loadDataBtn, loadStatusEl, replayUIContainerEl, scoreboardEl, matchInfoEl,
            matchDateEl, matchTimeEl, matchVenueEl, matchRefereeEl, matchAttendanceEl, setElapsedTimeEl,
            courtAreaEl, allRalliesDurationChartAreaEl, allRalliesDurationVisualizationEl,
            rallyStatsSummaryAreaEl, rallyStatsSummaryContentEl, playerScoredRalliesDurationChartAreaEl,
            playerScoredRalliesDurationVisualizationEl, playerScoredRallyStatsSummaryAreaEl,
            playerScoredRallyStatsSummaryContentEl, statsAreaEl, setNumberEl, teamANameEl,
            teamAPointsEl, teamASetsEl, teamBNameEl, teamBPointsEl, teamBSetsEl, eventDescEl,
            nextEventBtn, prevEventBtn, playPauseBtn, skipToEndBtn, statsTeamANameEl, statsTeamATbody,
            statsTeamATfoot, statsTeamBNameEl, statsTeamBTbody, statsTeamBTfoot, courtSideAEl, courtSideBEl,
            toggleAdvancedStatsBtn, advancedStatsContainerEl, advancedSetSummariesContentEl,
            advancedSideoutContentEl, advancedPointrunsContentEl, advancedPlayerPointsSetContentEl,
            advancedLeadChangesMaxLeadsContentEl, advancedTimeoutPerformanceContentEl, advancedServingStreaksContentEl,
            advancedServeReceivePointsContentEl, advancedAvgPointsServiceTurnContentEl, advancedRotationalPerformanceContentEl,
            openRouterApiKeyInput, generateAiAnalysisBtn, aiAnalysisStatusEl, aiAnalysisOutputAreaEl, aiAnalysisContainerEl,
            streakCourtTooltipEl, streakCourtTooltipContentEl, mainContentContainerEl;

        let loadedGameData = null, currentEventIndex = -1, sortedEvents = [], currentSet = 0;
        let teamAPoints = 0, teamBPoints = 0, teamASets = 0, teamBSets = 0;
        let servingTeam = null, lastServingTeam = null;
        let playerPositionsA = {}, playerPositionsB = {};
        let playerStats = {};
        let teamATimeouts = 0, teamBTimeouts = 0, teamASubs = 0, teamBSubs = 0;
        let teamAImpliedOpponentErrors = 0, teamBImpliedOpponentErrors = 0;
        let teamAId = null, teamBId = null;
        let currentSetStartTime = null;
        let pointScorerHighlightTimeout = null, lostPointHighlightTimeout = null;
        let gameHistory = [];
        let isPlaying = false, playIntervalId = null;
        let currentGameAdvancedStats = null;
        let advancedStatsRendered = false;

        function setStatusMessage(element, message, type = 'info') { if(element) {element.textContent = message; let className = 'mt-2 text-sm h-5 '; if (type === 'loading') className += 'status-loading'; else if (type === 'error') className += 'status-error'; else if (type === 'success') className += 'status-success'; element.className = className;} }

        function calculateMean(dataArray) { if (!dataArray || dataArray.length === 0) return 0; const sum = dataArray.reduce((acc, val) => acc + val, 0); return sum / dataArray.length; }
        function calculateMedian(dataArray) { if (!dataArray || dataArray.length === 0) return 0; const sorted = [...dataArray].sort((a, b) => a - b); const mid = Math.floor(sorted.length / 2); return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2; }
        function calculateRange(dataArray) { if (!dataArray || dataArray.length === 0) return { min: 0, max: 0 }; return { min: Math.min(...dataArray), max: Math.max(...dataArray) }; }
        function calculateStandardDeviation(dataArray) { if (!dataArray || dataArray.length === 0) return 0; const mean = calculateMean(dataArray); const variance = dataArray.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / dataArray.length; return Math.sqrt(variance); }

        function calculateRallyDurations(gameSortedEvents) {
            const rallyDurations = []; let lastRallyStartTimeSeconds = null; let currentSetNumberForRally = 0; let rallyInSetCounter = 0; let setScoreA = 0; let setScoreB = 0;
            for (const event of gameSortedEvents) {
                const eventTimeSeconds = parseTimeToSeconds(event.wall_time); if (eventTimeSeconds === null) continue;
                if (event.code === 'aloitajakso') {
                    currentSetNumberForRally = parseInt(event.period); rallyInSetCounter = 0; setScoreA = 0; setScoreB = 0; lastRallyStartTimeSeconds = eventTimeSeconds;
                    const servingTeamEventForSet = gameSortedEvents.find(e => parseInt(e.period) === currentSetNumberForRally && e.code === 'aloittavajoukkue' && parseTimeToSeconds(e.wall_time) >= eventTimeSeconds);
                    if (servingTeamEventForSet) { const servingTime = parseTimeToSeconds(servingTeamEventForSet.wall_time); if (servingTime !== null) lastRallyStartTimeSeconds = servingTime; }
                } else if (event.code === 'aloittavajoukkue' && currentSetNumberForRally > 0 && rallyInSetCounter === 0) {
                     const aloittavaTimeSeconds = parseTimeToSeconds(event.wall_time); if (aloittavaTimeSeconds && (!lastRallyStartTimeSeconds || aloittavaTimeSeconds >= lastRallyStartTimeSeconds)) { lastRallyStartTimeSeconds = aloittavaTimeSeconds; }
                } else if (event.code === 'piste' && currentSetNumberForRally > 0) {
                    if (lastRallyStartTimeSeconds !== null && eventTimeSeconds > lastRallyStartTimeSeconds) {
                        const duration = eventTimeSeconds - lastRallyStartTimeSeconds; rallyInSetCounter++; let scoringTeamSymbol = null;
                        const scoreMatch = event.description?.match(/(\d+)-(\d+)/); if (scoreMatch) { const newScoreA = parseInt(scoreMatch[1]); const newScoreB = parseInt(scoreMatch[2]); if (newScoreA > setScoreA) scoringTeamSymbol = 'A'; else if (newScoreB > setScoreB) scoringTeamSymbol = 'B'; setScoreA = newScoreA; setScoreB = newScoreB; }
                        let rallyScorerPlayerId = null; if (event.player_id && String(event.player_id) !== '1') { rallyScorerPlayerId = String(event.player_id); }
                        rallyDurations.push({ rallyOverallNumber: rallyDurations.length + 1, rallyInSetNumber: rallyInSetCounter, setNumber: currentSetNumberForRally, durationSeconds: duration, startTimeWallTime: lastRallyStartTimeSeconds ? formatSecondsToMMSS(lastRallyStartTimeSeconds % (24*3600)).replace(/^00:/, '') : "N/A", endTimeWallTime: event.wall_time, scoringTeam: scoringTeamSymbol, scorerPlayerId: rallyScorerPlayerId });
                    } lastRallyStartTimeSeconds = eventTimeSeconds;
                } else if (event.code === 'lopetaottelu') { break; }
            } return rallyDurations;
        }

        function displayGenericRallyDurationBarChart(rallyDurations, targetVisualizationEl, chartTitle) {
            targetVisualizationEl.innerHTML = '';
            if (!rallyDurations || rallyDurations.length === 0) { targetVisualizationEl.innerHTML = `<p class="text-center text-gray-500">No rally data for "${chartTitle}".</p>`; return; }
            const validRallies = rallyDurations.filter(r => r.durationSeconds > 0);
            if (validRallies.length === 0) { targetVisualizationEl.innerHTML = `<p class="text-center text-gray-500">No valid positive rally durations for "${chartTitle}".</p>`; return; }
            const maxDuration = Math.ceil(Math.max(...validRallies.map(r => r.durationSeconds)));
            const chartHeight = 220; const xAxisLabelHeight = 30; const yAxisLabelWidth = 35; const chartAreaPaddingTop = 10;
            const totalSvgHeight = chartHeight + xAxisLabelHeight + chartAreaPaddingTop; const barGap = 3; const minBarWidth = 5;
            const chartDrawableWidth = targetVisualizationEl.clientWidth > yAxisLabelWidth ? targetVisualizationEl.clientWidth - yAxisLabelWidth : 200;
            const calculatedBarWidth = Math.max(minBarWidth, (chartDrawableWidth - (validRallies.length * barGap)) / validRallies.length);
            const totalContentWidthBars = validRallies.length * (calculatedBarWidth + barGap);
            const totalSvgWidth = totalContentWidthBars + yAxisLabelWidth;
            const svgNS = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", Math.max(targetVisualizationEl.clientWidth, totalSvgWidth)); svg.setAttribute("height", totalSvgHeight); svg.style.display = "block";
            const numTicks = 5;
            for (let i = 0; i <= numTicks; i++) {
                const tickValue = (maxDuration / numTicks) * i; const tickY = chartAreaPaddingTop + chartHeight - (tickValue / maxDuration) * chartHeight;
                const textLabel = document.createElementNS(svgNS, "text"); textLabel.setAttribute("x", yAxisLabelWidth - 5); textLabel.setAttribute("y", tickY + 3); textLabel.classList.add("y-axis-label"); textLabel.textContent = `${Math.round(tickValue)}s`; svg.appendChild(textLabel);
                const gridLine = document.createElementNS(svgNS, "line"); gridLine.setAttribute("x1", yAxisLabelWidth); gridLine.setAttribute("y1", tickY); gridLine.setAttribute("x2", yAxisLabelWidth + totalContentWidthBars); gridLine.setAttribute("y2", tickY); gridLine.classList.add("y-axis-line"); svg.appendChild(gridLine);
            }
            validRallies.forEach((rally, index) => {
                const barHeight = maxDuration > 0 ? (rally.durationSeconds / maxDuration) * chartHeight : 0; const x = yAxisLabelWidth + index * (calculatedBarWidth + barGap);
                const rect = document.createElementNS(svgNS, "rect"); rect.setAttribute("x", x); rect.setAttribute("y", chartAreaPaddingTop + chartHeight - barHeight); rect.setAttribute("width", calculatedBarWidth); rect.setAttribute("height", barHeight);
                let barColor = "#9ca3af"; const isTeamAInfoAvailable = teamAId && playerStats && Object.values(playerStats).some(p => p.team === 'A'); const isTeamBInfoAvailable = teamBId && playerStats && Object.values(playerStats).some(p => p.team === 'B');
                if (rally.scoringTeam === 'A' && isTeamAInfoAvailable) barColor = "#3b82f6"; else if (rally.scoringTeam === 'B' && isTeamBInfoAvailable) barColor = "#ef4444";
                rect.setAttribute("fill", barColor);
                const titleText = `Rally ${rally.rallyOverallNumber} (Set ${rally.setNumber}, #${rally.rallyInSetNumber}): ${rally.durationSeconds.toFixed(1)}s. Scored by Team ${rally.scoringTeam || 'N/A'}${rally.scorerPlayerId && playerStats && playerStats[rally.scorerPlayerId] ? ' (Player: ' + playerStats[rally.scorerPlayerId].name + ' #' + playerStats[rally.scorerPlayerId].shirt + ')' : ''}. End: ${rally.endTimeWallTime}`;
                const title = document.createElementNS(svgNS, "title"); title.textContent = titleText; rect.appendChild(title); svg.appendChild(rect);
                if (calculatedBarWidth >= 15) { const xLabel = document.createElementNS(svgNS, "text"); xLabel.setAttribute("x", x + calculatedBarWidth / 2); xLabel.setAttribute("y", chartAreaPaddingTop + chartHeight + 15); xLabel.setAttribute("text-anchor", "middle"); xLabel.setAttribute("font-size", "9px"); xLabel.setAttribute("fill", "#4b5563"); xLabel.textContent = `${rally.rallyOverallNumber}`; svg.appendChild(xLabel); }
            });
            targetVisualizationEl.appendChild(svg);
        }

        function displayRallyStatsSummary(rallyDurationsData) {
            rallyStatsSummaryContentEl.innerHTML = '';
            if (!rallyDurationsData || rallyDurationsData.length === 0) { rallyStatsSummaryContentEl.innerHTML = '<p class="text-center text-gray-500">No rally data to calculate statistics.</p>'; return; }
            const durations = rallyDurationsData.map(r => r.durationSeconds).filter(d => d > 0);
            if (durations.length === 0) { rallyStatsSummaryContentEl.innerHTML = '<p class="text-center text-gray-500">No valid positive rally durations found.</p>'; return; }
            const mean = calculateMean(durations); const median = calculateMedian(durations); const range = calculateRange(durations); const stdDev = calculateStandardDeviation(durations);
            const statsTable = document.createElement('table'); statsTable.id = 'rally-stats-summary-table'; statsTable.className = 'w-full advanced-stats-table';
            const tbody = statsTable.createTBody();
            function addStatRow(label, value, unit = 's') { const row = tbody.insertRow(); const cellLabel = row.insertCell(); cellLabel.textContent = label; cellLabel.className = 'font-semibold text-gray-600'; const cellValue = row.insertCell(); if (typeof value === 'number' && !isNaN(value)) { cellValue.textContent = unit ? value.toFixed(1) + unit : value.toString(); } else { cellValue.textContent = value || 'N/A'; } cellValue.className = 'text-gray-800'; }
            addStatRow('Total Rallies Analyzed:', durations.length, null); addStatRow('Mean Rally Length:', mean); addStatRow('Median Rally Length:', median); addStatRow('Shortest Rally (Min):', range.min); addStatRow('Longest Rally (Max):', range.max); addStatRow('Standard Deviation:', stdDev);
            rallyStatsSummaryContentEl.appendChild(statsTable);
        }
        function displayPlayerScoredRallyStatsSummary(rallyDurationsData) {
            playerScoredRallyStatsSummaryContentEl.innerHTML = '';
            if (!rallyDurationsData || rallyDurationsData.length === 0) { playerScoredRallyStatsSummaryContentEl.innerHTML = '<p class="text-center text-gray-500">No rally data to calculate statistics.</p>'; return; }
            const playerScoredRallies = rallyDurationsData.filter(r => r.scorerPlayerId !== null);
            if (playerScoredRallies.length === 0) { playerScoredRallyStatsSummaryContentEl.innerHTML = '<p class="text-center text-gray-500">No rallies were found with a specific player marked as scorer.</p>'; return; }
            const durations = playerScoredRallies.map(r => r.durationSeconds).filter(d => d > 0);
            if (durations.length === 0) { playerScoredRallyStatsSummaryContentEl.innerHTML = '<p class="text-center text-gray-500">No valid positive durations for player-scored rallies.</p>'; return; }
            const mean = calculateMean(durations); const median = calculateMedian(durations); const range = calculateRange(durations); const stdDev = calculateStandardDeviation(durations);
            const statsTable = document.createElement('table'); statsTable.id = 'player-scored-rally-stats-table'; statsTable.className = 'w-full advanced-stats-table';
            const tbody = statsTable.createTBody();
            function addStatRow(label, value, unit = 's') { const row = tbody.insertRow(); const cellLabel = row.insertCell(); cellLabel.textContent = label; cellLabel.className = 'font-semibold text-gray-600'; const cellValue = row.insertCell(); if (typeof value === 'number' && !isNaN(value)) { cellValue.textContent = unit ? value.toFixed(1) + unit : value.toString(); } else { cellValue.textContent = value || 'N/A'; } cellValue.className = 'text-gray-800'; }
            addStatRow('Player-Scored Rallies Analyzed:', durations.length, null); addStatRow('Mean Length (Player-Scored):', mean); addStatRow('Median Length (Player-Scored):', median); addStatRow('Shortest (Player-Scored):', range.min); addStatRow('Longest (Player-Scored):', range.max); addStatRow('Std. Deviation (Player-Scored):', stdDev);
            playerScoredRallyStatsSummaryContentEl.appendChild(statsTable);
        }

        // --- Advanced Statistics Calculation Functions ---
        function calculateSetSummaries(gameSortedEvents, teamAName, teamBName) {
            const setSummaries = []; let currentSetData = null;
            gameSortedEvents.forEach(event => {
                const eventPeriod = parseInt(event.period);
                if (event.code === 'aloitajakso' && eventPeriod > 0) {
                    if (currentSetData && currentSetData.setNumber !== eventPeriod) { setSummaries.push(currentSetData); currentSetData = null; }
                    if (!currentSetData || currentSetData.setNumber !== eventPeriod) { currentSetData = { setNumber: eventPeriod, startTime: parseTimeToSeconds(event.wall_time), endTime: null, durationSeconds: null, scoreA: 0, scoreB: 0, winningTeamName: null, margin: null }; }
                }
                if (currentSetData && event.period == currentSetData.setNumber) {
                    if (event.code === 'piste') { const scoreMatch = event.description?.match(/(\d+)-(\d+)/); if (scoreMatch) { currentSetData.scoreA = parseInt(scoreMatch[1]); currentSetData.scoreB = parseInt(scoreMatch[2]); } }
                    else if (event.code === 'maali') {
                        currentSetData.endTime = parseTimeToSeconds(event.wall_time);
                        if (currentSetData.startTime && currentSetData.endTime) { currentSetData.durationSeconds = currentSetData.endTime - currentSetData.startTime; }
                        if (currentSetData.scoreA > currentSetData.scoreB) { currentSetData.winningTeamName = teamAName; currentSetData.margin = currentSetData.scoreA - currentSetData.scoreB; }
                        else if (currentSetData.scoreB > currentSetData.scoreA) { currentSetData.winningTeamName = teamBName; currentSetData.margin = currentSetData.scoreB - currentSetData.scoreA; }
                        else { currentSetData.winningTeamName = "Tie/Ongoing"; currentSetData.margin = 0; }
                        setSummaries.push(currentSetData); currentSetData = null;
                    }
                }
            });
            if (currentSetData && !currentSetData.endTime) {
                const gameEndEvent = gameSortedEvents.find(e => e.code === 'lopetaottelu');
                if (gameEndEvent) {
                    currentSetData.endTime = parseTimeToSeconds(gameEndEvent.wall_time);
                     if (currentSetData.startTime && currentSetData.endTime) { currentSetData.durationSeconds = currentSetData.endTime - currentSetData.startTime; }
                     if (currentSetData.scoreA > currentSetData.scoreB) { currentSetData.winningTeamName = teamAName; currentSetData.margin = currentSetData.scoreA - currentSetData.scoreB; }
                     else if (currentSetData.scoreB > currentSetData.scoreA) { currentSetData.winningTeamName = teamBName; currentSetData.margin = currentSetData.scoreB - currentSetData.scoreA; }
                }
                if(currentSetData) setSummaries.push(currentSetData);
            }
            return setSummaries;
        }

        function calculateSideOutAndPointRuns(gameSortedEvents, teamAId_param, teamBId_param) {
            let sideOutsA = { opportunities: 0, successful: 0 }; let sideOutsB = { opportunities: 0, successful: 0 };
            let longestRunA = 0, currentRunA = 0; let longestRunB = 0, currentRunB = 0;
            let currentServingTeamId = null;
            gameSortedEvents.forEach(event => {
                const eventPeriod = parseInt(event.period);
                if (event.code === 'aloitajakso') { currentServingTeamId = null; currentRunA = 0; currentRunB = 0; }
                else if (event.code === 'aloittavajoukkue') { currentServingTeamId = String(event.team_id); }
                else if (event.code === 'piste') {
                    const pointWinnerIdByEvent = String(event.team_id);
                    if (currentServingTeamId && currentServingTeamId !== pointWinnerIdByEvent) {
                        if (currentServingTeamId === teamAId_param) { sideOutsB.opportunities++; sideOutsB.successful++; }
                        else if (currentServingTeamId === teamBId_param) { sideOutsA.opportunities++; sideOutsA.successful++; }
                    } else if (currentServingTeamId && currentServingTeamId === pointWinnerIdByEvent) {
                        if (currentServingTeamId === teamAId_param) sideOutsB.opportunities++; else if (currentServingTeamId === teamBId_param) sideOutsA.opportunities++;
                    }
                    currentServingTeamId = pointWinnerIdByEvent;
                    if (pointWinnerIdByEvent === teamAId_param) { currentRunA++; longestRunA = Math.max(longestRunA, currentRunA); currentRunB = 0; }
                    else if (pointWinnerIdByEvent === teamBId_param) { currentRunB++; longestRunB = Math.max(longestRunB, currentRunB); currentRunA = 0; }
                }
            });
            return { sideOutsTeamA: { ...sideOutsA, percentage: sideOutsA.opportunities > 0 ? (sideOutsA.successful / sideOutsA.opportunities * 100) : 0 }, sideOutsTeamB: { ...sideOutsB, percentage: sideOutsB.opportunities > 0 ? (sideOutsB.successful / sideOutsB.opportunities * 100) : 0 }, longestRunTeamA: longestRunA, longestRunTeamB: longestRunB };
        }

        function calculatePlayerPointsPerSet(gameSortedEvents, lineupData, teamAId_param, teamBId_param) {
            const playerSetPoints = {}; if (!lineupData || !lineupData.match || !lineupData.match.lineups) return playerSetPoints;
            lineupData.match.lineups.forEach(p => { playerSetPoints[String(p.player_id)] = { name: p.player_name, shirt: p.shirt_number, teamSymbol: p.team_id === teamAId_param ? 'A' : (p.team_id === teamBId_param ? 'B' : '?'), setPoints: {} }; });
            gameSortedEvents.forEach(event => {
                if (event.code === 'piste' && event.player_id && String(event.player_id) !== '1') {
                    const playerId = String(event.player_id); const setNumber = parseInt(event.period);
                    if (playerSetPoints[playerId] && setNumber > 0) { if (!playerSetPoints[playerId].setPoints[setNumber]) { playerSetPoints[playerId].setPoints[setNumber] = 0; } playerSetPoints[playerId].setPoints[setNumber]++; }
                }
            }); return playerSetPoints;
        }

        function calculateLeadChangesAndMaxLeads(gameSortedEvents, teamAId_param, teamBId_param) {
            const setStats = {}; let currentSetScores = {A: 0, B: 0}; let currentSetLeadingTeam = null;
            let currentPeriod = 0;
            gameSortedEvents.forEach(event => {
                const eventPeriod = parseInt(event.period);
                if (event.code === 'aloitajakso' && eventPeriod > 0) {
                    if (currentPeriod > 0 && setStats[currentPeriod]) { /* Already finalized by maali or implicitly */ }
                    currentPeriod = eventPeriod;
                    setStats[currentPeriod] = { setNumber: currentPeriod, leadChanges: 0, maxLeadA: 0, maxLeadB: 0, finalScoreA: 0, finalScoreB: 0 };
                    currentSetScores = {A: 0, B: 0}; currentSetLeadingTeam = null;
                }
                if (event.code === 'piste' && eventPeriod === currentPeriod && eventPeriod > 0) {
                    const scoreMatch = event.description?.match(/(\d+)-(\d+)/);
                    if (scoreMatch) {
                        const pointsA = parseInt(scoreMatch[1]); const pointsB = parseInt(scoreMatch[2]);
                        currentSetScores.A = pointsA; currentSetScores.B = pointsB;
                        setStats[currentPeriod].finalScoreA = pointsA; setStats[currentPeriod].finalScoreB = pointsB;
                        const newLeadingTeam = pointsA > pointsB ? 'A' : (pointsB > pointsA ? 'B' : null);
                        if (currentSetLeadingTeam && newLeadingTeam && currentSetLeadingTeam !== newLeadingTeam) { setStats[currentPeriod].leadChanges++; }
                        currentSetLeadingTeam = newLeadingTeam;
                        if (pointsA > pointsB) setStats[currentPeriod].maxLeadA = Math.max(setStats[currentPeriod].maxLeadA, pointsA - pointsB);
                        else if (pointsB > pointsA) setStats[currentPeriod].maxLeadB = Math.max(setStats[currentPeriod].maxLeadB, pointsB - pointsA);
                    }
                } else if (event.code === 'maali' && eventPeriod === currentPeriod && eventPeriod > 0) { /* Max leads already tracked per point */ }
            });
            return Object.values(setStats);
        }

        function calculateTimeoutPerformance(gameSortedEvents, teamAId_param, teamBId_param) {
            const perf = { teamA_afterOwn: { scored: 0, opportunities: 0 }, teamA_afterOpponent: { scored: 0, opportunities: 0 }, teamB_afterOwn: { scored: 0, opportunities: 0 }, teamB_afterOpponent: { scored: 0, opportunities: 0 } };
            for (let i = 0; i < gameSortedEvents.length; i++) {
                const event = gameSortedEvents[i];
                if (event.code === 'aikalisa') {
                    const timeoutTeamId = String(event.team_id); let nextPointEvent = null;
                    for (let j = i + 1; j < gameSortedEvents.length; j++) { if (gameSortedEvents[j].code === 'piste') { nextPointEvent = gameSortedEvents[j]; break; } if (gameSortedEvents[j].code === 'aikalisa' || gameSortedEvents[j].code === 'aloitajakso' || gameSortedEvents[j].code === 'maali') break; }
                    if (nextPointEvent) {
                        const pointWinnerId = String(nextPointEvent.team_id);
                        if (timeoutTeamId === teamAId_param) { perf.teamA_afterOwn.opportunities++; if (pointWinnerId === teamAId_param) perf.teamA_afterOwn.scored++; }
                        else if (timeoutTeamId === teamBId_param) { perf.teamB_afterOwn.opportunities++; if (pointWinnerId === teamBId_param) perf.teamB_afterOwn.scored++; }
                        if (timeoutTeamId === teamBId_param) { perf.teamA_afterOpponent.opportunities++; if (pointWinnerId === teamAId_param) perf.teamA_afterOpponent.scored++; }
                        else if (timeoutTeamId === teamAId_param) { perf.teamB_afterOpponent.opportunities++; if (pointWinnerId === teamBId_param) perf.teamB_afterOpponent.scored++; }
                    }
                }
            }
            Object.keys(perf).forEach(key => { perf[key].percentage = perf[key].opportunities > 0 ? (perf[key].scored / perf[key].opportunities * 100) : 0; });
            return perf;
        }

        // Serving-streaks calculation moved into `js/stats_calculator.js` and is imported in the module.

        function calculateServeReceiveAndBreakPoints(gameSortedEvents, teamAId_param, teamBId_param) {
            const stats = {
                teamA: { pointsOnOwnServe: 0, pointsOnOpponentServe: 0, breakPointsWon: 0, serviceOpportunities: 0 },
                teamB: { pointsOnOwnServe: 0, pointsOnOpponentServe: 0, breakPointsWon: 0, serviceOpportunities: 0 }
            };
            let currentServingTeamId = null;
            gameSortedEvents.forEach(event => {
                if (event.code === 'aloittavajoukkue') {
                    currentServingTeamId = String(event.team_id);
                    if (currentServingTeamId === teamAId_param) stats.teamA.serviceOpportunities++; else if (currentServingTeamId === teamBId_param) stats.teamB.serviceOpportunities++;
                } else if (event.code === 'piste') {
                    const pointWinnerId = String(event.team_id);
                    if (currentServingTeamId) {
                        if (currentServingTeamId === teamAId_param) { // A serving
                            if (pointWinnerId === teamAId_param) stats.teamA.pointsOnOwnServe++;
                            else { stats.teamB.pointsOnOpponentServe++; stats.teamB.breakPointsWon++; }
                        } else if (currentServingTeamId === teamBId_param) { // B serving
                            if (pointWinnerId === teamBId_param) stats.teamB.pointsOnOwnServe++;
                            else { stats.teamA.pointsOnOpponentServe++; stats.teamA.breakPointsWon++; }
                        }
                    }
                    // Update serving team for next point & count new service opportunity if sideout
                    if (currentServingTeamId !== pointWinnerId) {
                        currentServingTeamId = pointWinnerId;
                        if (currentServingTeamId === teamAId_param) stats.teamA.serviceOpportunities++;
                        else if (currentServingTeamId === teamBId_param) stats.teamB.serviceOpportunities++;
                    }
                } else if (event.code === 'aloitajakso') {
                    currentServingTeamId = null;
                }
            });
            return stats;
        }

        function calculateAveragePointsPerServiceTurn(gameSortedEvents, teamAId_param, teamBId_param) {
            const stats = {
                teamA: { totalServiceTurns: 0, totalPointsOnServiceTurns: 0, average: 0 },
                teamB: { totalServiceTurns: 0, totalPointsOnServiceTurns: 0, average: 0 }
            };
            let currentServingTeamId = null;
            let pointsThisTurn = 0;

            gameSortedEvents.forEach(event => {
                if (event.code === 'aloittavajoukkue') {
                    if (currentServingTeamId && pointsThisTurn >= 0) { // Finalize previous turn, even if 0 points
                        if (currentServingTeamId === teamAId_param) stats.teamA.totalPointsOnServiceTurns += pointsThisTurn;
                        else if (currentServingTeamId === teamBId_param) stats.teamB.totalPointsOnServiceTurns += pointsThisTurn;
                    }
                    currentServingTeamId = String(event.team_id);
                    pointsThisTurn = 0;
                    if (currentServingTeamId === teamAId_param) stats.teamA.totalServiceTurns++;
                    else if (currentServingTeamId === teamBId_param) stats.teamB.totalServiceTurns++;
                } else if (event.code === 'piste') {
                    const pointWinnerId = String(event.team_id);
                    if (currentServingTeamId) {
                        if (currentServingTeamId === pointWinnerId) {
                            pointsThisTurn++;
                        } else {
                            if (currentServingTeamId === teamAId_param) stats.teamA.totalPointsOnServiceTurns += pointsThisTurn;
                            else if (currentServingTeamId === teamBId_param) stats.teamB.totalPointsOnServiceTurns += pointsThisTurn;

                            currentServingTeamId = pointWinnerId;
                            pointsThisTurn = 0;
                            if (currentServingTeamId === teamAId_param) stats.teamA.totalServiceTurns++;
                            else if (currentServingTeamId === teamBId_param) stats.teamB.totalServiceTurns++;
                        }
                    } else {
                        currentServingTeamId = pointWinnerId;
                        pointsThisTurn = 0;
                        if (currentServingTeamId === teamAId_param) stats.teamA.totalServiceTurns++;
                        else if (currentServingTeamId === teamBId_param) stats.teamB.totalServiceTurns++;
                    }
                } else if (event.code === 'aloitajakso') {
                    if (currentServingTeamId && pointsThisTurn >= 0) {
                         if (currentServingTeamId === teamAId_param) stats.teamA.totalPointsOnServiceTurns += pointsThisTurn;
                         else if (currentServingTeamId === teamBId_param) stats.teamB.totalPointsOnServiceTurns += pointsThisTurn;
                    }
                    currentServingTeamId = null; pointsThisTurn = 0;
                }
            });
            if (currentServingTeamId && pointsThisTurn >= 0) { // Finalize last turn
                if (currentServingTeamId === teamAId_param) stats.teamA.totalPointsOnServiceTurns += pointsThisTurn;
                else if (currentServingTeamId === teamBId_param) stats.teamB.totalPointsOnServiceTurns += pointsThisTurn;
            }
            if (stats.teamA.totalServiceTurns > 0) stats.teamA.average = stats.teamA.totalPointsOnServiceTurns / stats.teamA.totalServiceTurns;
            if (stats.teamB.totalServiceTurns > 0) stats.teamB.average = stats.teamB.totalPointsOnServiceTurns / stats.teamB.totalServiceTurns;
            return stats;
        }

        // --- Advanced Statistics Display Functions ---
        function renderSetSummariesTable(setSummaries, targetElementId) {
            const contentEl = document.getElementById(targetElementId); contentEl.innerHTML = '';
            if (!setSummaries || setSummaries.length === 0) { contentEl.innerHTML = '<p>No set summary data available.</p>'; return; }
            const table = document.createElement('table'); table.className = 'w-full advanced-stats-table text-center';
            const thead = table.createTHead(); const headerRow = thead.insertRow();
            ["Set", "Score", "Winner", "Margin", "Duration"].forEach(text => { const th = document.createElement('th'); th.textContent = text; headerRow.appendChild(th); });
            const tbody = table.createTBody();
            setSummaries.forEach(s => { const row = tbody.insertRow(); row.insertCell().textContent = s.setNumber; row.insertCell().textContent = `${s.scoreA} - ${s.scoreB}`; row.insertCell().textContent = s.winningTeamName || 'N/A'; row.insertCell().textContent = s.margin !== null ? s.margin : 'N/A'; row.insertCell().textContent = s.durationSeconds !== null ? formatSecondsToMMSS(s.durationSeconds) : 'N/A'; });
            contentEl.appendChild(table);
        }

        function renderSideOutPercentageTable(sideOutData, targetElementId) {
            const contentEl = document.getElementById(targetElementId); contentEl.innerHTML = '';
            if (!sideOutData) { contentEl.innerHTML = '<p>No side-out data available.</p>'; return; }
            const table = document.createElement('table'); table.className = 'w-full md:w-3/4 lg:w-1/2 mx-auto advanced-stats-table';
            const thead = table.createTHead(); const headerRow = thead.insertRow();
            ["Team", "Side-Out %", "Successful/Opportunities"].forEach(text => { const th = document.createElement('th'); th.textContent = text; headerRow.appendChild(th); });
            const tbody = table.createTBody();
            function createRow(teamName, data) { const row = tbody.insertRow(); row.insertCell().textContent = teamName; row.insertCell().textContent = `${data.percentage.toFixed(1)}%`; row.insertCell().textContent = `${data.successful}/${data.opportunities}`; }
            if (teamANameEl.textContent && sideOutData.sideOutsTeamA) createRow(teamANameEl.textContent, sideOutData.sideOutsTeamA);
            if (teamBNameEl.textContent && sideOutData.sideOutsTeamB) createRow(teamBNameEl.textContent, sideOutData.sideOutsTeamB);
            contentEl.appendChild(table);
        }

        function renderLongestPointRunsTable(pointRunData, targetElementId) {
            const contentEl = document.getElementById(targetElementId); contentEl.innerHTML = '';
            if (!pointRunData) { contentEl.innerHTML = '<p>No point run data available.</p>'; return; }
             const table = document.createElement('table'); table.className = 'w-full md:w-3/4 lg:w-1/2 mx-auto advanced-stats-table';
            const thead = table.createTHead(); const headerRow = thead.insertRow();
            ["Team", "Longest Run"].forEach(text => { const th = document.createElement('th'); th.textContent = text; headerRow.appendChild(th); });
            const tbody = table.createTBody();
            if (teamANameEl.textContent) { const rowA = tbody.insertRow(); rowA.insertCell().textContent = teamANameEl.textContent; rowA.insertCell().textContent = pointRunData.longestRunTeamA; }
            if (teamBNameEl.textContent) { const rowB = tbody.insertRow(); rowB.insertCell().textContent = teamBNameEl.textContent; rowB.insertCell().textContent = pointRunData.longestRunTeamB; }
            contentEl.appendChild(table);
        }

        function renderPlayerPointsPerSetTable(playerPointsData, targetElementId) {
            const contentEl = document.getElementById(targetElementId); contentEl.innerHTML = '';
            if (!playerPointsData || Object.keys(playerPointsData).length === 0) { contentEl.innerHTML = '<p>No player points per set data.</p>'; return; }
            const allSets = new Set(); Object.values(playerPointsData).forEach(player => Object.keys(player.setPoints).forEach(setNum => allSets.add(parseInt(setNum))));
            const sortedSets = Array.from(allSets).sort((a,b) => a - b);
            const table = document.createElement('table'); table.className = 'w-full advanced-stats-table text-sm';
            const thead = table.createTHead(); const headerRow = thead.insertRow(); const headers = ["#", "Player", "Team"];
            sortedSets.forEach(setNum => headers.push(`Set ${setNum}`)); headers.push("Total");
            headers.forEach(text => { const th = document.createElement('th'); th.textContent = text; th.className="text-center"; headerRow.appendChild(th); });
            const tbody = table.createTBody();
            const sortedPlayers = Object.values(playerPointsData).filter(p => p.shirt).sort((a,b) => (a.teamSymbol.localeCompare(b.teamSymbol)) || (parseInt(a.shirt) - parseInt(b.shirt)) );
            sortedPlayers.forEach(player => {
                const row = tbody.insertRow(); row.insertCell().textContent = player.shirt; row.insertCell().textContent = player.name; row.insertCell().textContent = player.teamSymbol;
                let totalPoints = 0;
                sortedSets.forEach(setNum => { const pointsInSet = player.setPoints[setNum] || 0; row.insertCell().textContent = pointsInSet > 0 ? pointsInSet : '-'; totalPoints += pointsInSet; });
                row.insertCell().textContent = totalPoints > 0 ? totalPoints : '-';
                 Array.from(row.cells).forEach(cell => cell.className = 'text-center'); row.cells[1].className = 'text-left';
            }); contentEl.appendChild(table);
        }

        function renderLeadChangesMaxLeadsTable(leadData, targetElementId) {
            const contentEl = document.getElementById(targetElementId); contentEl.innerHTML = '';
            if (!leadData || leadData.length === 0) { contentEl.innerHTML = '<p>No lead change/max lead data.</p>'; return; }
            const table = document.createElement('table'); table.className = 'w-full advanced-stats-table text-center';
            const thead = table.createTHead(); const headerRow = thead.insertRow();
            ["Set", "Final Score", "Lead Changes", `Max Lead ${teamANameEl.textContent || 'Team A'}`, `Max Lead ${teamBNameEl.textContent || 'Team B'}`].forEach(text => { const th = document.createElement('th'); th.textContent = text; headerRow.appendChild(th); });
            const tbody = table.createTBody();
            leadData.sort((a,b) => a.setNumber - b.setNumber).forEach(s => { const row = tbody.insertRow(); row.insertCell().textContent = s.setNumber; row.insertCell().textContent = `${s.finalScoreA} - ${s.finalScoreB}`; row.insertCell().textContent = s.leadChanges; row.insertCell().textContent = s.maxLeadA; row.insertCell().textContent = s.maxLeadB; });
            contentEl.appendChild(table);
        }

        function renderTimeoutPerformanceTable(perfData, targetElementId) {
            const contentEl = document.getElementById(targetElementId); contentEl.innerHTML = '';
            if (!perfData) { contentEl.innerHTML = '<p>No timeout performance data.</p>'; return; }
            const table = document.createElement('table'); table.className = 'w-full md:w-3/4 lg:w-2/3 mx-auto advanced-stats-table';
            const thead = table.createTHead(); const headerRow = thead.insertRow();
            ["Scenario", "Team", "Point Won %", "Scored/Opportunities"].forEach(text => { const th = document.createElement('th'); th.textContent = text; headerRow.appendChild(th); });
            const tbody = table.createTBody();
            function addRow(scenario, teamName, data) { const row = tbody.insertRow(); row.insertCell().textContent = scenario; row.insertCell().textContent = teamName; row.insertCell().textContent = `${data.percentage.toFixed(1)}%`; row.insertCell().textContent = `${data.scored}/${data.opportunities}`; }
            addRow("After Own Timeout", teamANameEl.textContent || 'Team A', perfData.teamA_afterOwn); addRow("After Opponent's Timeout", teamANameEl.textContent || 'Team A', perfData.teamA_afterOpponent);
            addRow("After Own Timeout", teamBNameEl.textContent || 'Team B', perfData.teamB_afterOwn); addRow("After Opponent's Timeout", teamBNameEl.textContent || 'Team B', perfData.teamB_afterOpponent);
            contentEl.appendChild(table);
        }

        function showStreakCourtTooltip(streakData, targetElement) {
            if (!streakCourtTooltipEl || !streakCourtTooltipContentEl || !streakData?.courtState) return;

            streakCourtTooltipContentEl.innerHTML = ''; // Clear previous content

            const courtContainer = document.createElement('div');
            courtContainer.className = 'flex items-stretch justify-center court-container';

            const courtSideA = document.createElement('div');
            courtSideA.className = 'court-side w-1/2 grid grid-cols-2 grid-rows-3';
            ['a-5','a-4','a-6','a-3','a-1','a-2'].forEach(zoneId => {
                const zone = document.createElement('div');
                zone.className = 'court-zone';
                zone.id = `tooltip-zone-${zoneId}`;
                courtSideA.appendChild(zone);
            });

            const net = document.createElement('div');
            net.className = 'net w-0.5 mx-0';

            const courtSideB = document.createElement('div');
            courtSideB.className = 'court-side w-1/2 grid grid-cols-2 grid-rows-3';
            ['b-2','b-1','b-3','b-6','b-4','b-5'].forEach(zoneId => {
                const zone = document.createElement('div');
                zone.className = 'court-zone';
                zone.id = `tooltip-zone-${zoneId}`;
                courtSideB.appendChild(zone);
            });

            courtContainer.appendChild(courtSideA);
            courtContainer.appendChild(net);
            courtContainer.appendChild(courtSideB);
            streakCourtTooltipContentEl.appendChild(courtContainer);

            // Draw player markers using the saved state
            const formatPlayerNameForMarker = (fullName) => { if (!fullName || typeof fullName !== 'string') return ''; const parts = fullName.trim().split(' '); if (parts.length === 0) return ''; const firstName = parts[0]; let lastNameInitial = ''; if (parts.length > 1) { lastNameInitial = parts[parts.length - 1].charAt(0).toUpperCase() + '.'; } return parts.length === 1 ? firstName : `${firstName} ${lastNameInitial}`; };
            const drawMarkers = (positions, teamClass, servingPlayerId) => {
                for (const zone in positions) {
                    const playerId = positions[zone];
                    if (playerId && playerStats[playerId]) {
                        const zoneEl = document.getElementById(`tooltip-zone-${teamClass}-${zone}`);
                        if (zoneEl) {
                            const marker = document.createElement('div');
                            marker.className = 'player-marker';
                            marker.classList.add(teamClass === 'a' ? 'team-a' : 'team-b');
                            const numberSpan = document.createElement('span');
                            numberSpan.className = 'shirt-number';
                            numberSpan.textContent = playerStats[playerId].shirt;
                            const nameSpan = document.createElement('span');
                            nameSpan.className = 'player-name-on-marker';
                            nameSpan.textContent = formatPlayerNameForMarker(playerStats[playerId].name);
                            marker.appendChild(numberSpan);
                            marker.appendChild(nameSpan);
                            if (playerId === servingPlayerId) {
                                marker.classList.add('serving');
                            }
                            zoneEl.appendChild(marker);
                        }
                    }
                }
            };
            drawMarkers(streakData.courtState.a, 'a', streakData.playerId);
            drawMarkers(streakData.courtState.b, 'b', streakData.playerId);

            // Position and show the tooltip
            const mainContainerRect = mainContentContainerEl.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();

            let top = (targetRect.bottom - mainContainerRect.top) + 5;
            let left = (targetRect.left - mainContainerRect.left);

            // Adjust if tooltip goes off-screen
            if (left + streakCourtTooltipEl.offsetWidth > mainContainerRect.width) {
                left = mainContainerRect.width - streakCourtTooltipEl.offsetWidth - 20;
            }
             if (top + streakCourtTooltipEl.offsetHeight > (window.innerHeight - mainContainerRect.top)) {
                 top = (targetRect.top - mainContainerRect.top) - streakCourtTooltipEl.offsetHeight - 5;
            }


            streakCourtTooltipEl.style.top = `${top}px`;
            streakCourtTooltipEl.style.left = `${left}px`;
            streakCourtTooltipEl.classList.add('visible');
        }

        function hideStreakCourtTooltip() {
            if (!streakCourtTooltipEl) return;
            streakCourtTooltipEl.classList.remove('visible');
        }

        function renderServingStreaksTable(streakData, targetElementId) {
            const contentEl = document.getElementById(targetElementId); contentEl.innerHTML = '';
            if (!streakData || streakData.length === 0) { contentEl.innerHTML = '<p>No serving streak data available.</p>'; return; }

            const byTeam = { A: [], B: [] };
            streakData.forEach(s => { if (!s) return; if (s.teamSymbol === 'A') byTeam.A.push(s); else byTeam.B.push(s); });
            byTeam.A.sort((a,b) => b.streak - a.streak); byTeam.B.sort((a,b) => b.streak - a.streak);

            const topContainer = document.createElement('div'); topContainer.className = 'grid grid-cols-1 md:grid-cols-2 gap-4 mb-4';
            const makeTeamCard = (teamSymbol, arr) => {
                const card = document.createElement('div'); card.className = 'p-2 border rounded';
                const title = document.createElement('div'); title.className = 'font-semibold mb-1'; title.textContent = teamSymbol === 'A' ? (teamANameEl.textContent || 'Team A') : (teamBNameEl.textContent || 'Team B');
                card.appendChild(title);
                if (arr.length === 0) {
                    const p = document.createElement('p'); p.className = 'text-sm text-gray-500'; p.textContent = 'No serving streaks.'; card.appendChild(p);
                } else {
                    const best = arr[0];
                    const p = document.createElement('p'); p.innerHTML = `<strong>${best.shirt} - ${best.name}</strong>  Longest serving streak: <strong>${best.streak}</strong> (Set ${best.setNum})`;
                    card.appendChild(p);
                    if (arr.length > 1) {
                        const sub = document.createElement('div'); sub.className = 'text-sm text-gray-600 mt-1'; sub.textContent = `${arr.length} streaks recorded`; card.appendChild(sub);
                    }
                }
                return card;
            };
            topContainer.appendChild(makeTeamCard('A', byTeam.A)); topContainer.appendChild(makeTeamCard('B', byTeam.B));
            contentEl.appendChild(topContainer);

            const table = document.createElement('table'); table.className = 'w-full md:w-3/4 lg:w-2/3 mx-auto advanced-stats-table';
            const thead = table.createTHead(); const headerRow = thead.insertRow(); ["#", "Player (Shirt - Name)", "Team", "Set", "Streak (consecutive team points)"]
                .forEach(text => { const th = document.createElement('th'); th.textContent = text; headerRow.appendChild(th); });
            const tbody = table.createTBody();

            let idx = 1;
            const all = [...byTeam.A, ...byTeam.B].sort((a,b) => b.streak - a.streak || a.teamSymbol.localeCompare(b.teamSymbol));

            all.forEach(s => {
                if (!s) return;
                const row = tbody.insertRow();
                row.insertCell().textContent = idx++;
                const playerCell = row.insertCell();
                playerCell.textContent = `${s.shirt} - ${s.name}`;
                playerCell.style.cursor = s.courtState ? 'pointer' : 'default';
                playerCell.style.textDecoration = s.courtState ? 'underline' : 'none';
                playerCell.style.textDecorationStyle = s.courtState ? 'dotted' : 'none';

                if (s.courtState) {
                    playerCell.addEventListener('mouseover', (e) => showStreakCourtTooltip(s, e.currentTarget));
                    playerCell.addEventListener('mouseout', hideStreakCourtTooltip);
                }

                row.insertCell().textContent = s.teamSymbol === 'A' ? (teamANameEl.textContent || 'Team A') : (teamBNameEl.textContent || 'Team B');
                row.insertCell().textContent = s.setNum || '-';
                row.insertCell().textContent = s.streak;
                row.cells[4].classList.add('text-center');
            });

            if (tbody.rows.length === 0) {
                const p = document.createElement('p'); p.className = 'text-center text-gray-500'; p.textContent = 'No serving streaks of length 2+ found.'; contentEl.appendChild(p);
            } else {
                contentEl.appendChild(table);
            }
        }

        function renderServeReceivePointsTable(data, targetElementId) {
            const contentEl = document.getElementById(targetElementId); contentEl.innerHTML = '';
            if (!data) { contentEl.innerHTML = '<p>No serve/receive point data.</p>'; return; }
            const table = document.createElement('table'); table.className = 'w-full md:w-3/4 lg:w-2/3 mx-auto advanced-stats-table';
            const thead = table.createTHead(); const headerRow = thead.insertRow();
            ["Team", "Points on Own Serve", "Points on Opponent's Serve (Breaks)"].forEach(text => { const th = document.createElement('th'); th.textContent = text; th.className="text-center"; headerRow.appendChild(th); });
            const tbody = table.createTBody();
            function addRow(teamName, stats) { const r = tbody.insertRow(); r.insertCell().textContent = teamName; r.insertCell().textContent = stats.pointsOnOwnServe; r.insertCell().textContent = `${stats.pointsOnOpponentServe} (${stats.breakPointsWon})`; Array.from(r.cells).forEach(c => c.classList.add('text-center')); r.cells[0].classList.remove('text-center'); r.cells[0].classList.add('text-left');}
            if(teamANameEl.textContent) addRow(teamANameEl.textContent, data.teamA);
            if(teamBNameEl.textContent) addRow(teamBNameEl.textContent, data.teamB);
            contentEl.appendChild(table);
        }

        function renderAvgPointsServiceTurnTable(data, targetElementId) {
            const contentEl = document.getElementById(targetElementId); contentEl.innerHTML = '';
            if (!data) { contentEl.innerHTML = '<p>No avg points per service turn data.</p>'; return; }
            const table = document.createElement('table'); table.className = 'w-full md:w-3/4 lg:w-1/2 mx-auto advanced-stats-table';
            const thead = table.createTHead(); const headerRow = thead.insertRow();
            ["Team", "Avg. Points per Service Turn", "Total Points / Total Turns"].forEach(text => { const th = document.createElement('th'); th.textContent = text; th.className="text-center"; headerRow.appendChild(th); });
            const tbody = table.createTBody();
            function addRow(teamName, stats) { const r = tbody.insertRow(); r.insertCell().textContent = teamName; r.insertCell().textContent = stats.average.toFixed(2); r.insertCell().textContent = `${stats.totalPointsOnServiceTurns} / ${stats.totalServiceTurns}`; Array.from(r.cells).forEach(c => c.classList.add('text-center')); r.cells[0].classList.remove('text-center'); r.cells[0].classList.add('text-left');}
            if(teamANameEl.textContent) addRow(teamANameEl.textContent, data.teamA);
            if(teamBNameEl.textContent) addRow(teamBNameEl.textContent, data.teamB);
            contentEl.appendChild(table);
        }

        function renderRotationalPerformanceTable(rotationalData, targetElementId) {
            const contentEl = document.getElementById(targetElementId);
            contentEl.innerHTML = '';
            if (!rotationalData || (!Object.keys(rotationalData.teamA).length && !Object.keys(rotationalData.teamB).length)) {
                contentEl.innerHTML = '<p>No rotational performance data available.</p>';
                return;
            }

            const createTeamTable = (teamSymbol, data) => {
                const container = document.createElement('div');
                const teamName = teamSymbol === 'A' ? (teamANameEl.textContent || 'Team A') : (teamBNameEl.textContent || 'Team B');
                const header = document.createElement('h6');
                header.className = 'font-semibold text-gray-700 mt-2 mb-1';
                header.textContent = teamName;
                container.appendChild(header);

                if (Object.keys(data).length === 0) {
                    container.innerHTML += '<p class="text-sm text-gray-500">No rotations recorded for this team.</p>';
                    return container;
                }

                const table = document.createElement('table');
                table.className = 'w-full advanced-stats-table text-sm';
                const thead = table.createTHead();
                const headerRow = thead.insertRow();
                ["Rotation (Server)", "Points For", "Points Against", "Differential", "Total Rallies"].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                const tbody = table.createTBody();
                Object.values(data).sort((a, b) => (b.pointsFor - b.pointsAgainst) - (a.pointsFor - a.pointsAgainst)).forEach(rot => {
                    const diff = rot.pointsFor - rot.pointsAgainst;
                    const row = tbody.insertRow();
                    row.insertCell().textContent = `${rot.player.shirt} - ${rot.player.name}`;
                    row.insertCell().textContent = rot.pointsFor;
                    row.insertCell().textContent = rot.pointsAgainst;
                    const diffCell = row.insertCell();
                    diffCell.textContent = diff > 0 ? `+${diff}` : diff;
                    diffCell.className = diff > 0 ? 'text-green-600 font-bold' : (diff < 0 ? 'text-red-600 font-bold' : '');
                    row.insertCell().textContent = rot.totalRallies;
                });
                container.appendChild(table);
                return container;
            };

            contentEl.appendChild(createTeamTable('A', rotationalData.teamA));
            contentEl.appendChild(createTeamTable('B', rotationalData.teamB));
        }

        /** Renders starting positions per set for both teams. Expects loadedGameData.match.lineups to contain playing_position mapping per set. */
        function renderStartingPositionsTables(matchData, teamAId_param, teamBId_param, targetElementId) {
            const contentEl = document.getElementById(targetElementId); contentEl.innerHTML = '';
            if (!matchData || !matchData.lineups || !Array.isArray(matchData.lineups)) { contentEl.innerHTML = '<p>No lineup data available.</p>'; return; }
            // Determine sets present in playing_position entries
            const sets = new Set(); matchData.lineups.forEach(p => { if (p.playing_position && typeof p.playing_position === 'object') { Object.keys(p.playing_position).forEach(s => { const sn = parseInt(s); if (!isNaN(sn)) sets.add(sn); }); } });
            const setNumbers = Array.from(sets).sort((a,b) => a - b);
            if (setNumbers.length === 0) { contentEl.innerHTML = '<p>No starting-position information found in lineups.</p>'; return; }

            // For each set, create a small table showing positions 1..6 and player (shirt + name) for Team A and Team B
            setNumbers.forEach(setNum => {
                const header = document.createElement('h6'); header.className = 'font-semibold text-gray-700 mb-1'; header.textContent = `Set ${setNum}`;
                const table = document.createElement('table'); table.className = 'w-full advanced-stats-table mb-3 text-center';
                const thead = table.createTHead(); const headRow = thead.insertRow(); ['Position','Team A (shirt - name)','Team B (shirt - name)'].forEach(t => { const th = document.createElement('th'); th.textContent = t; headRow.appendChild(th); });
                const tbody = table.createTBody();
                for (let pos = 1; pos <= 6; pos++) {
                    const row = tbody.insertRow();
                    row.insertCell().textContent = pos;
                    // Find player for Team A in this position & set
                    const playerA = matchData.lineups.find(p => String(p.team_id) === String(teamAId_param) && p.playing_position && p.playing_position[setNum] == pos);
                    const playerB = matchData.lineups.find(p => String(p.team_id) === String(teamBId_param) && p.playing_position && p.playing_position[setNum] == pos);
                    row.insertCell().textContent = playerA ? `${playerA.shirt_number} - ${playerA.player_name}` : '-';
                    row.insertCell().textContent = playerB ? `${playerB.shirt_number} - ${playerB.player_name}` : '-';
                }
                contentEl.appendChild(header); contentEl.appendChild(table);
            });
        }


        function displayAdvancedGameStats() {
            if (!currentGameAdvancedStats) { console.warn("Advanced stats data not calculated yet."); return; }
            renderSetSummariesTable(currentGameAdvancedStats.setSummaries, 'advanced-set-summaries-content');
            renderSideOutPercentageTable(currentGameAdvancedStats.sideOutAndPointRuns, 'advanced-sideout-content');
            renderLongestPointRunsTable(currentGameAdvancedStats.sideOutAndPointRuns, 'advanced-pointruns-content');
            renderPlayerPointsPerSetTable(currentGameAdvancedStats.playerPointsPerSet, 'advanced-player-points-set-content');
            renderLeadChangesMaxLeadsTable(currentGameAdvancedStats.leadChangesMaxLeads, 'advanced-leadchanges-maxleads-content');
            renderTimeoutPerformanceTable(currentGameAdvancedStats.timeoutPerformance, 'advanced-timeout-performance-content');
            renderServingStreaksTable(currentGameAdvancedStats.servingStreaks, 'advanced-serving-streaks-content');
            renderServeReceivePointsTable(currentGameAdvancedStats.serveReceivePoints, 'advanced-serve-receive-points-content');
            renderAvgPointsServiceTurnTable(currentGameAdvancedStats.avgPointsServiceTurn, 'advanced-avg-points-service-turn-content');
            renderRotationalPerformanceTable(currentGameAdvancedStats.rotationalStats, 'advanced-rotational-performance-content');
            // Starting positions table (uses loadedGameData.match)
            try { renderStartingPositionsTables(loadedGameData?.match, teamAId, teamBId, 'advanced-starting-positions-content'); } catch (e) { console.warn('Failed to render starting positions', e); }
            advancedStatsRendered = true;
        }

        // --- START: AI Analysis Logic ---

        /**
         * Gathers all relevant game statistics into a structured object for the AI.
         */
        function collectStatsForAI() {
            if (!loadedGameData || !currentGameAdvancedStats) {
                return null;
            }

            const teamAName = teamANameEl.textContent || 'Team A';
            const teamBName = teamBNameEl.textContent || 'Team B';

            const simplifiedPlayerStats = (teamSymbol) => {
                return Object.values(playerStats)
                    .filter(p => p.team === teamSymbol)
                    .map(p => ({
                        name: p.name,
                        shirtNumber: p.shirt,
                        points: p.points,
                        serves: p.serves,
                        isCaptain: p.isCaptain
                    }));
            };

            const formatRotationalStatsForAI = (teamRotationalData) => {
                if (!teamRotationalData) return {};
                const formatted = {};
                for (const playerId in teamRotationalData) {
                    const rot = teamRotationalData[playerId];
                    const playerName = `${rot.player.name} (#${rot.player.shirt})`;
                    formatted[playerName] = {
                        pointsFor: rot.pointsFor,
                        pointsAgainst: rot.pointsAgainst,
                        differential: rot.pointsFor - rot.pointsAgainst,
                        totalRallies: rot.totalRallies
                    };
                }
                return formatted;
            };

            const stats = {
                matchInfo: {
                    teamA: teamAName,
                    teamB: teamBName,
                    finalScoreSets: `${teamASets} - ${teamBSets}`,
                    date: matchDateEl.textContent,
                    venue: matchVenueEl.textContent,
                },
                teamA_Stats: {
                    players: simplifiedPlayerStats('A'),
                    timeoutsUsed: teamATimeouts,
                    substitutions: teamASubs,
                    impliedOpponentErrors: teamAImpliedOpponentErrors,
                    rotationalPerformance: formatRotationalStatsForAI(currentGameAdvancedStats.rotationalStats.teamA)
                },
                teamB_Stats: {
                    players: simplifiedPlayerStats('B'),
                    timeoutsUsed: teamBTimeouts,
                    substitutions: teamBSubs,
                    impliedOpponentErrors: teamBImpliedOpponentErrors,
                    rotationalPerformance: formatRotationalStatsForAI(currentGameAdvancedStats.rotationalStats.teamB)
                },
                advancedStats: {
                    setSummaries: currentGameAdvancedStats.setSummaries.map(s => ({
                        set: s.setNumber,
                        score: `${s.scoreA} - ${s.scoreB}`,
                        winner: s.winningTeamName,
                        durationMinutes: s.durationSeconds ? (s.durationSeconds / 60).toFixed(1) : 'N/A'
                    })),
                    sideOutPercentage: {
                        teamA: `${currentGameAdvancedStats.sideOutAndPointRuns.sideOutsTeamA.percentage.toFixed(1)}%`,
                        teamB: `${currentGameAdvancedStats.sideOutAndPointRuns.sideOutsTeamB.percentage.toFixed(1)}%`
                    },
                    longestPointRuns: {
                        teamA: currentGameAdvancedStats.sideOutAndPointRuns.longestRunTeamA,
                        teamB: currentGameAdvancedStats.sideOutAndPointRuns.longestRunTeamB
                    },
                    longestServingStreaks: currentGameAdvancedStats.servingStreaks.slice(0, 5).map(s => ({ // Top 5
                        player: `${s.name} (#${s.shirt})`,
                        team: s.teamSymbol === 'A' ? teamAName : teamBName,
                        streak: s.streak,
                        set: s.setNum
                    })),
                    pointsOnServeVsReception: {
                        teamA: currentGameAdvancedStats.serveReceivePoints.teamA,
                        teamB: currentGameAdvancedStats.serveReceivePoints.teamB
                    }
                }
            };

            return stats;
        }


        /**
         * Sends the collected stats to OpenRouter.ai for analysis.
         */
        async function getAIAnalysis() {
            const apiKey = openRouterApiKeyInput.value.trim();
            if (!apiKey) {
                setStatusMessage(aiAnalysisStatusEl, 'Please enter your OpenRouter.ai API key.', 'error');
                return;
            }
             // Save the key to localStorage for convenience
            localStorage.setItem('openrouter_api_key', apiKey);


            const gameStats = collectStatsForAI();
            if (!gameStats) {
                setStatusMessage(aiAnalysisStatusEl, 'Game data is not fully loaded or processed.', 'error');
                return;
            }

            setStatusMessage(aiAnalysisStatusEl, 'Analyzing stats with AI...', 'loading');
            generateAiAnalysisBtn.disabled = true;
            aiAnalysisOutputAreaEl.innerHTML = '<p class="text-center text-gray-500">AI is thinking...</p>';

            const statsJson = JSON.stringify(gameStats, null, 2);
            const historicalAverages = null; // Placeholder for future implementation

            const prompt = `
You are a expert volleyball analyst with 20+ years coaching elite teams. Your goal is to uncover hidden gems, surprises, and tactical edges from match data  not just recap numbers. Be concise, evidence-based, and exciting.

Data to analyze (JSON):
${statsJson}

${historicalAverages ? `Season averages for comparison: ${JSON.stringify(historicalAverages, null, 2)}` : ''}

Step 1: Analyze Rotational Performance. The \`rotationalPerformance\` key for each team shows the point differential when a specific player is the server (in position 1). A high positive differential indicates a strong rotation. A negative one is a weak rotation. Identify the BEST and WORST rotation for each team. For the worst rotation, speculate on the cause (e.g., weak server, poor serve receive, bad matchup).
Step 2: Scan for other anomalies (e.g., a player's high point total but low serving streak, unusual error clusters, or significant side-out percentage differences).
Step 3: Identify key patterns (e.g., a team's success being tied to a specific player's performance, or one team dominating after timeouts).
Step 4: Suggest 2-3 actionable, specific tweaks for the losing team for a potential rematch.

Provide your analysis in the following format:

**Rotational Analysis:**
- **[Team A Name]:**
  - **Strongest Rotation:** [Player Name], Differential: [+/- X]
  - **Weakest Rotation:** [Player Name], Differential: [+/- X]
  - **Tactical Insight:** [Your brief analysis of their rotations]
- **[Team B Name]:**
  - **Strongest Rotation:** [Player Name], Differential: [+/- X]
  - **Weakest Rotation:** [Player Name], Differential: [+/- X]
  - **Tactical Insight:** [Your brief analysis of their rotations]

**Key Match Insights (Top 3):**
1. [Finding 1: Brief description + key stat + why it matters]
2. [Finding 2: ...]
3. [Finding 3: ...]

**Actionable Advice for [Losing Team Name]:**
- [Tweak 1: ...]
- [Tweak 2: ...]
  `;
            try {
                const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${apiKey}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        "model": "openai/gpt-3.5-turbo", // You can change this to any model on OpenRouter
                        "messages": [
                            { "role": "user", "content": prompt }
                        ]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                }

                const data = await response.json();
                const analysis = data.choices[0].message.content;

                // Basic formatting for display
                let formattedAnalysis = analysis
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                    .replace(/\n/g, '<br>');

                aiAnalysisOutputAreaEl.innerHTML = formattedAnalysis;
                setStatusMessage(aiAnalysisStatusEl, 'Analysis complete.', 'success');

            } catch (error) {
                console.error('Error fetching AI analysis:', error);
                setStatusMessage(aiAnalysisStatusEl, `Error: ${error.message}`, 'error');
                aiAnalysisOutputAreaEl.innerHTML = `<p class="text-center text-red-500">Failed to get analysis. Check your API key and the console for details.</p>`;
            } finally {
                generateAiAnalysisBtn.disabled = false;
            }
        }

        // --- END: AI Analysis Logic ---

        async function loadTeamMatches() {
            let url = teamMatchesUrlInput.value.trim(); if (!url) { setStatusMessage(teamLoadStatusEl, 'Please enter a Team Matches URL.', 'error'); return; }
            setStatusMessage(teamLoadStatusEl, 'Loading team matches...', 'loading'); loadTeamMatchesBtn.disabled = true; matchListDisplayAreaEl.innerHTML = '';
            try {
                let parsedUrl; try { parsedUrl = new URL(url); } catch (_) { throw new Error('Invalid URL format.'); }
                if (!parsedUrl.pathname.includes('getMatches')) { throw new Error('URL does not appear to be a getMatches URL.'); }
                if (!parsedUrl.searchParams.get('team_id')) { throw new Error('URL is missing the required team_id parameter.'); }

                // Use fetchWithFallback to attempt direct -> local proxy -> public proxies
                const data = await fetchWithFallback(url, { preferLocalRaw: true, timeoutMs: 12000 });
                if (!data?.matches || !Array.isArray(data.matches)) { throw new Error('Invalid response format: Missing "matches" array.'); }
                displayMatchList(data.matches, data.team_name); setStatusMessage(teamLoadStatusEl, `Found ${data.matches.length} matches for ${data.team_name}. Select a game to load.`, 'success');
            } catch (error) { console.error('Error loading team matches:', error); setStatusMessage(teamLoadStatusEl, `Error: ${error.message}`, 'error'); matchListDisplayAreaEl.innerHTML = '<p class="text-red-500">Could not load matches.</p>'; }
            finally { loadTeamMatchesBtn.disabled = false; }
        }
        function displayMatchList(matches) {
            matchListDisplayAreaEl.innerHTML = '';
            if (matches.length === 0) { matchListDisplayAreaEl.innerHTML = '<p>No matches found for this team.</p>'; return; }
            const listTitle = document.createElement('h3'); listTitle.className = 'text-md font-semibold text-gray-700 mb-2'; listTitle.textContent = 'Select a Game to Replay:'; matchListDisplayAreaEl.appendChild(listTitle);
            const ul = document.createElement('ul'); ul.className = 'space-y-2';
            matches.forEach(match => {
                const li = document.createElement('li'); li.className = 'match-list-item'; li.classList.add(match.status === 'Played' ? 'played' : 'not-played');
                const dateStr = match.date ? new Date(match.date).toLocaleDateString() : 'No Date';
                const score = (match.fs_A !== null && match.fs_B !== null) ? `(${match.fs_A} - ${match.fs_B})` : '';
                li.innerHTML = `<div class="font-medium">${match.team_A_name || 'Team A'} vs ${match.team_B_name || 'Team B'} ${score}</div> <div class="text-xs text-gray-500">${dateStr} - Status: ${match.status || 'Unknown'}</div>`;
                if (match.status === 'Played' && match.match_id) {
                    li.title = `Click to load replay for match ID ${match.match_id}`;
                    li.addEventListener('click', () => { const getMatchUrl = `${API_BASE_URL}getMatch?match_id=${match.match_id}`; gameUrlInput.value = getMatchUrl; loadGameData(getMatchUrl); replayUIContainerEl.scrollIntoView({ behavior: 'smooth' }); });
                } else { li.style.cursor = 'not-allowed'; li.title = match.match_id ? 'This game is not marked as "Played".' : 'Match ID missing.'; }
                ul.appendChild(li);
            });
            matchListDisplayAreaEl.appendChild(ul);
        }
        async function loadGameData(url) {
            if (!url) return;
            setStatusMessage(loadStatusEl, 'Loading game data...', 'loading'); loadDataBtn.disabled = true; teamLoadStatusEl.textContent = ''; resetUIState();
            try {
                let parsedUrl; try { parsedUrl = new URL(url); } catch (_) { throw new Error('Invalid URL format.'); }
                if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') { throw new Error('URL must use http or https.'); }
                if (!parsedUrl.searchParams.get('match_id')) { throw new Error('URL is missing the required match_id parameter for getMatch.'); }
                // Use fetchWithFallback to attempt direct -> local proxy -> public proxies
                const data = await fetchWithFallback(url, { preferLocalRaw: false, timeoutMs: 12000 });
                if (!data?.match?.events || !Array.isArray(data.match.events) || !data?.match?.lineups || !Array.isArray(data.match.lineups) || !data?.match?.team_A_id || !data?.match?.team_B_id) { throw new Error('Invalid game data: Missing critical fields like events, lineups, or team IDs.'); }
                loadedGameData = data; setStatusMessage(loadStatusEl, 'Game data loaded successfully!', 'success'); initializeGame(); replayUIContainerEl.classList.remove('opacity-50');
            } catch (error) { console.error('Error loading game data:', error); setStatusMessage(loadStatusEl, `Error: ${error.message}`, 'error'); loadedGameData = null; resetUIState(); }
            finally { loadDataBtn.disabled = false; }
        }
        function resetUIState() {
            pausePlayback(); replayUIContainerEl.classList.add('opacity-50');
            prevEventBtn.disabled = true; playPauseBtn.disabled = true; playPauseBtn.textContent = 'Play'; nextEventBtn.disabled = true; skipToEndBtn.disabled = true;
            eventDescEl.textContent = 'Load game data or select from a team list.';
            setNumberEl.textContent = '-'; teamANameEl.textContent = 'Team A'; teamAPointsEl.textContent = '0'; teamASetsEl.textContent = '0'; teamBNameEl.textContent = 'Team B'; teamBPointsEl.textContent = '0'; teamBSetsEl.textContent = '0';
            matchDateEl.textContent = 'Date'; matchTimeEl.textContent = 'Time'; matchVenueEl.textContent = 'Venue'; matchRefereeEl.textContent = 'Referee'; matchAttendanceEl.textContent = '0'; setElapsedTimeEl.textContent = '--:--';
            statsTeamANameEl.textContent = `Team A Stats`; statsTeamBNameEl.textContent = `Team B Stats`;
            statsTeamATbody.innerHTML = ''; statsTeamATfoot.innerHTML = ''; statsTeamBTbody.innerHTML = ''; statsTeamBTfoot.innerHTML = '';
            document.querySelectorAll('.player-marker').forEach(marker => marker.remove());

            allRalliesDurationVisualizationEl.innerHTML = '<p class="text-center text-gray-500">Rally duration chart will appear here.</p>';
            allRalliesDurationChartAreaEl.classList.add('opacity-50');
            rallyStatsSummaryContentEl.innerHTML = '<p class="text-center text-gray-500">Rally statistics will appear here.</p>';
            rallyStatsSummaryAreaEl.classList.add('opacity-50');
            playerScoredRalliesDurationVisualizationEl.innerHTML = '<p class="text-center text-gray-500">Player-scored rally chart will appear here.</p>';
            playerScoredRalliesDurationChartAreaEl.classList.add('opacity-50');
            playerScoredRallyStatsSummaryContentEl.innerHTML = '<p class="text-center text-gray-500">Player-scored rally stats will appear here.</p>';
            playerScoredRallyStatsSummaryAreaEl.classList.add('opacity-50');

            advancedStatsContainerEl.style.display = 'none'; toggleAdvancedStatsBtn.textContent = 'Show Advanced Game Statistics'; toggleAdvancedStatsBtn.disabled = true;
            const placeholderText = '<p class="text-gray-400 italic text-center">Data will appear here.</p>';
            advancedSetSummariesContentEl.innerHTML = placeholderText;
            advancedSideoutContentEl.innerHTML = placeholderText;
            advancedPointrunsContentEl.innerHTML = placeholderText;
            advancedPlayerPointsSetContentEl.innerHTML = placeholderText;
            // Starting positions placeholder
            const startingPositionsEl = document.getElementById('advanced-starting-positions-content'); if (startingPositionsEl) startingPositionsEl.innerHTML = placeholderText;
            advancedLeadChangesMaxLeadsContentEl.innerHTML = placeholderText;
            advancedTimeoutPerformanceContentEl.innerHTML = placeholderText;
            advancedServingStreaksContentEl.innerHTML = placeholderText;
            advancedServeReceivePointsContentEl.innerHTML = placeholderText;
            advancedAvgPointsServiceTurnContentEl.innerHTML = placeholderText;
            if (advancedRotationalPerformanceContentEl) advancedRotationalPerformanceContentEl.innerHTML = placeholderText;
            currentGameAdvancedStats = null; advancedStatsRendered = false;
            loadedGameData = null; currentEventIndex = -1; sortedEvents = []; gameHistory = [];

            aiAnalysisContainerEl.style.display = 'none';
            generateAiAnalysisBtn.disabled = true;
            aiAnalysisOutputAreaEl.innerHTML = '<p class="text-center text-gray-500">AI analysis will appear here.</p>';
            setStatusMessage(aiAnalysisStatusEl, '', 'info');
        }

        function initializeGame() {
            console.log("DEBUG: Starting initializeGame...");
            if (!loadedGameData?.match) {
                console.error("DEBUG: initializeGame failed - loadedGameData.match is missing.");
                resetUIState();
                return;
            }
            pausePlayback();
            const matchData = loadedGameData.match;
            teamAId = matchData.team_A_id; teamBId = matchData.team_B_id;
            teamANameEl.textContent = matchData.team_A_name || 'Team A'; statsTeamANameEl.textContent = `${matchData.team_A_name || 'Team A'} Stats`;
            teamBNameEl.textContent = matchData.team_B_name || 'Team B'; statsTeamBNameEl.textContent = `${matchData.team_B_name || 'Team B'} Stats`;
            matchDateEl.textContent = matchData.date || 'N/A'; matchTimeEl.textContent = matchData.time || 'N/A'; matchVenueEl.textContent = matchData.venue_name || 'N/A'; matchRefereeEl.textContent = matchData.referee_1_name || 'N/A'; matchAttendanceEl.textContent = matchData.attendance || '0';

            // Use the new stats calculator for final totals
            const finalGameStats = calculateGameStats(loadedGameData);
            teamATimeouts = finalGameStats?.teamAInfo?.timeouts ?? 0;
            teamBTimeouts = finalGameStats?.teamBInfo?.timeouts ?? 0;
            teamASubs = finalGameStats?.teamAInfo?.subs ?? 0;
            teamBSubs = finalGameStats?.teamBInfo?.subs ?? 0;
            teamAImpliedOpponentErrors = finalGameStats?.teamAInfo?.impliedOpponentErrors ?? 0;
            teamBImpliedOpponentErrors = finalGameStats?.teamBInfo?.impliedOpponentErrors ?? 0;

            playerStats = {};
            matchData.lineups.forEach(p => { const playerIdStr = String(p.player_id); if (playerIdStr && p.team_id && p.player_name && p.shirt_number !== undefined) { playerStats[playerIdStr] = { name: p.player_name, shirt: p.shirt_number, team: p.team_id === teamAId ? 'A' : 'B', points: 0, serves: 0, isCaptain: p.captain === 'C' }; } });
            sortedEvents = [...matchData.events].sort((a, b) => { if (!a.wall_time || !b.wall_time) return 0; if (a.wall_time < b.wall_time) return -1; if (a.wall_time > b.wall_time) return 1; return 0; });
            sortedEvents.unshift({ code: "startgame", period: "0", wall_time: "00:00:00", code_fi: "Game Starting", description: "" });
            currentEventIndex = -1; currentSet = 0; teamAPoints = 0; teamBPoints = 0; teamASets = 0; teamBSets = 0; servingTeam = null; lastServingTeam = null; playerPositionsA = {}; playerPositionsB = {}; currentSetStartTime = null; gameHistory = [];

            const rallyDurationsData = calculateRallyDurations(sortedEvents);
            displayGenericRallyDurationBarChart(rallyDurationsData, allRalliesDurationVisualizationEl, "All Rallies");
            allRalliesDurationChartAreaEl.classList.remove('opacity-50');
            displayRallyStatsSummary(rallyDurationsData);
            rallyStatsSummaryAreaEl.classList.remove('opacity-50');
            const playerScoredRallies = rallyDurationsData.filter(r => r.scorerPlayerId !== null);
            displayGenericRallyDurationBarChart(playerScoredRallies, playerScoredRalliesDurationVisualizationEl, "Player-Scored Rallies");
            playerScoredRalliesDurationChartAreaEl.classList.remove('opacity-50');
            displayPlayerScoredRallyStatsSummary(rallyDurationsData);
            playerScoredRallyStatsSummaryAreaEl.classList.remove('opacity-50');

            currentGameAdvancedStats = {
                setSummaries: calculateSetSummaries(sortedEvents, teamANameEl.textContent, teamBNameEl.textContent),
                sideOutAndPointRuns: calculateSideOutAndPointRuns(sortedEvents, teamAId, teamBId),
                playerPointsPerSet: calculatePlayerPointsPerSet(sortedEvents, loadedGameData, teamAId, teamBId),
                leadChangesMaxLeads: calculateLeadChangesAndMaxLeads(sortedEvents, teamAId, teamBId),
                timeoutPerformance: calculateTimeoutPerformance(sortedEvents, teamAId, teamBId),
                servingStreaks: calculateServingStreaks(sortedEvents, loadedGameData, teamAId, teamBId),
                serveReceivePoints: calculateServeReceiveAndBreakPoints(sortedEvents, teamAId, teamBId),
                avgPointsServiceTurn: calculateAveragePointsPerServiceTurn(sortedEvents, teamAId, teamBId),
                rotationalStats: (() => {
                    try {
                        return calculateRotationalStats(sortedEvents, loadedGameData, teamAId, teamBId);
                    } catch (e) {
                        console.error("Error calculating rotational stats:", e);
                        return { teamA: {}, teamB: {} }; // Return empty object on failure
                    }
                })()
            };
            advancedStatsRendered = false;
            toggleAdvancedStatsBtn.disabled = false;

            replayUIContainerEl.classList.remove('opacity-50');
            displayEvent(0); saveState(); updateStatsTable(); updateSetElapsedTimeUI(null);

            aiAnalysisContainerEl.style.display = 'block';
            generateAiAnalysisBtn.disabled = false;
            console.log("DEBUG: initializeGame completed successfully.");
        }

        function playPlayback() { if (!loadedGameData || isPlaying || currentEventIndex >= sortedEvents.length - 1) return; isPlaying = true; playPauseBtn.textContent = 'Pause'; playPauseBtn.classList.remove('bg-green-500', 'hover:bg-green-600'); playPauseBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600'); prevEventBtn.disabled = true; nextEventBtn.disabled = true; skipToEndBtn.disabled = true; const advanceStep = () => { if (currentEventIndex < sortedEvents.length - 1) { displayEvent(currentEventIndex + 1, false); const currentEventCode = sortedEvents[currentEventIndex]?.code; if (currentEventCode === 'lopetaottelu') { pausePlayback(); } } else { pausePlayback(); } }; advanceStep(); if (isPlaying) { playIntervalId = setInterval(advanceStep, playbackSpeed); } }
        function pausePlayback() { if (!isPlaying && !playIntervalId) return; isPlaying = false; if (playIntervalId) { clearInterval(playIntervalId); playIntervalId = null; } playPauseBtn.textContent = 'Play'; playPauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600'); playPauseBtn.classList.add('bg-green-500', 'hover:bg-green-600'); if(loadedGameData) { const isEnd = currentEventIndex >= sortedEvents.length - 1 || sortedEvents[currentEventIndex]?.code === 'lopetaottelu'; prevEventBtn.disabled = currentEventIndex <= 0; nextEventBtn.disabled = isEnd; playPauseBtn.disabled = isEnd; skipToEndBtn.disabled = isEnd; } else { prevEventBtn.disabled = true; nextEventBtn.disabled = true; playPauseBtn.disabled = true; skipToEndBtn.disabled = true; } }
        function saveState() { if (!loadedGameData) return; const state = { index: currentEventIndex, set: currentSet, pointsA: teamAPoints, pointsB: teamBPoints, setsA: teamASets, setsB: teamBSets, serving: servingTeam, lastServing: lastServingTeam, posA: JSON.parse(JSON.stringify(playerPositionsA)), posB: JSON.parse(JSON.stringify(playerPositionsB)), stats: JSON.parse(JSON.stringify(playerStats)), errorsA: teamAImpliedOpponentErrors, errorsB: teamBImpliedOpponentErrors, setStartTime: currentSetStartTime }; if (gameHistory.length === 0 || gameHistory[gameHistory.length - 1].index !== state.index) { gameHistory.push(state); } }
        function restoreState(state) { if (!loadedGameData || !state) return; currentEventIndex = state.index; currentSet = state.set; teamAPoints = state.pointsA; teamBPoints = state.pointsB; teamASets = state.setsA; teamBSets = state.setsB; servingTeam = state.serving; lastServingTeam = state.lastServing; playerPositionsA = JSON.parse(JSON.stringify(state.posA)); playerPositionsB = JSON.parse(JSON.stringify(state.posB)); playerStats = JSON.parse(JSON.stringify(state.stats)); teamAImpliedOpponentErrors = state.errorsA; teamBImpliedOpponentErrors = state.errorsB; currentSetStartTime = state.setStartTime; const event = sortedEvents[currentEventIndex]; eventDescEl.textContent = event?.code_fi || event?.code || "State Restored"; updateScoreboard(); drawCourt(); updateStatsTable(); updateSetElapsedTimeUI(event?.wall_time); pausePlayback(); }
        function rotateTeam(teamIdSymbol) { const currentPositions = teamIdSymbol === 'A' ? playerPositionsA : playerPositionsB; const newPositions = {}; newPositions[1] = currentPositions[2]; newPositions[6] = currentPositions[1]; newPositions[5] = currentPositions[6]; newPositions[4] = currentPositions[5]; newPositions[3] = currentPositions[4]; newPositions[2] = currentPositions[3]; for (let zone = 1; zone <= 6; zone++) { if (teamIdSymbol === 'A') playerPositionsA[zone] = newPositions[zone] || null; else playerPositionsB[zone] = newPositions[zone] || null; } }
        function setStartingLineup(setNumber) { playerPositionsA = {}; playerPositionsB = {}; if (!loadedGameData?.match?.lineups) return; loadedGameData.match.lineups.forEach(p => { const playerIdStr = String(p.player_id); if (p.playing_position?.[setNumber]) { const zone = p.playing_position[setNumber]; if (zone >= 1 && zone <= 6) { if (p.team_id === teamAId) playerPositionsA[zone] = playerIdStr; else playerPositionsB[zone] = playerIdStr; } } }); }
        function updateScoreboard() { setNumberEl.textContent = currentSet > 0 ? currentSet : '-'; teamAPointsEl.textContent = teamAPoints; teamBPointsEl.textContent = teamBPoints; teamASetsEl.textContent = teamASets; teamBSetsEl.textContent = teamBSets; }
        function drawCourt() {
            document.querySelectorAll('.player-marker').forEach(marker => marker.remove());
            const formatPlayerNameForMarker = (fullName) => { if (!fullName || typeof fullName !== 'string') return ''; const parts = fullName.trim().split(' '); if (parts.length === 0) return ''; const firstName = parts[0]; let lastNameInitial = ''; if (parts.length > 1) { lastNameInitial = parts[parts.length - 1].charAt(0).toUpperCase() + '.'; } return parts.length === 1 ? firstName : `${firstName} ${lastNameInitial}`; };
            const drawMarkers = (positions, teamClass) => { for (const zone in positions) { const playerId = positions[zone]; if (playerId && playerStats[playerId]) { const zoneEl = document.getElementById(`zone-${teamClass}-${zone}`); if (zoneEl) { const marker = document.createElement('div'); marker.classList.add('player-marker'); marker.classList.add(teamClass === 'a' ? 'team-a' : 'team-b'); marker.dataset.playerId = playerId; const numberSpan = document.createElement('span'); numberSpan.classList.add('shirt-number'); numberSpan.textContent = playerStats[playerId].shirt; const nameSpan = document.createElement('span'); nameSpan.classList.add('player-name-on-marker'); nameSpan.textContent = formatPlayerNameForMarker(playerStats[playerId].name); marker.title = playerStats[playerId].name; marker.appendChild(numberSpan); marker.appendChild(nameSpan); if ((servingTeam === 'A' && teamClass === 'a' && parseInt(zone) === 1) || (servingTeam === 'B' && teamClass === 'b' && parseInt(zone) === 1)) { marker.classList.add('serving'); } zoneEl.appendChild(marker); } } } };
            drawMarkers(playerPositionsA, 'a'); drawMarkers(playerPositionsB, 'b');
        }
        function updateStatsTable() {
            statsTeamATbody.innerHTML = ''; statsTeamATfoot.innerHTML = ''; statsTeamBTbody.innerHTML = ''; statsTeamBTfoot.innerHTML = '';
            Object.entries(playerStats).filter(([, stats]) => stats.shirt).sort(([,a],[,b]) => parseInt(a.shirt) - parseInt(b.shirt)).forEach(([playerId, stats]) => { const row = document.createElement('tr'); const captainMark = stats.isCaptain ? ' (C)' : ''; row.innerHTML = `<td>${stats.shirt}</td><td>${stats.name}${captainMark}</td><td>${stats.points}</td><td>${stats.serves}</td>`; if (stats.team === 'A') statsTeamATbody.appendChild(row); else statsTeamBTbody.appendChild(row); });
            const errorRowA = document.createElement('tr'); errorRowA.classList.add('summary-row'); errorRowA.innerHTML = `<td colspan="2">Opponent Errors (Implied)</td><td>${teamAImpliedOpponentErrors}</td><td>-</td>`; statsTeamATfoot.appendChild(errorRowA);
            const subsRowA = document.createElement('tr'); subsRowA.classList.add('summary-row'); subsRowA.innerHTML = `<td colspan="2">Total Substitutions</td><td>${teamASubs}</td><td>-</td>`; statsTeamATfoot.appendChild(subsRowA);
            const timeoutRowA = document.createElement('tr'); timeoutRowA.classList.add('summary-row'); timeoutRowA.innerHTML = `<td colspan="2">Timeouts Used</td><td>${teamATimeouts}</td><td>-</td>`; statsTeamATfoot.appendChild(timeoutRowA);
            const errorRowB = document.createElement('tr'); errorRowB.classList.add('summary-row'); errorRowB.innerHTML = `<td colspan="2">Opponent Errors (Implied)</td><td>${teamBImpliedOpponentErrors}</td><td>-</td>`; statsTeamBTfoot.appendChild(errorRowB);
            const subsRowB = document.createElement('tr'); subsRowB.classList.add('summary-row'); subsRowB.innerHTML = `<td colspan="2">Total Substitutions</td><td>${teamBSubs}</td><td>-</td>`; statsTeamBTfoot.appendChild(subsRowB);
            const timeoutRowB = document.createElement('tr'); timeoutRowB.classList.add('summary-row'); timeoutRowB.innerHTML = `<td colspan="2">Total Timeouts Used</td><td>${teamBTimeouts}</td><td>-</td>`; statsTeamBTfoot.appendChild(timeoutRowB);
        }
        function updateSetElapsedTimeUI(currentEventTimeStr) { if (currentSetStartTime && currentEventTimeStr) { const startSeconds = parseTimeToSeconds(currentSetStartTime); const currentSeconds = parseTimeToSeconds(currentEventTimeStr); if (startSeconds !== null && currentSeconds !== null && currentSeconds >= startSeconds) { const elapsedSeconds = currentSeconds - startSeconds; setElapsedTimeEl.textContent = formatSecondsToMMSS(elapsedSeconds); } else { setElapsedTimeEl.textContent = "--:--"; } } else { setElapsedTimeEl.textContent = "00:00"; } }
        function highlightPointScorer(playerId) { if (pointScorerHighlightTimeout) clearTimeout(pointScorerHighlightTimeout); document.querySelectorAll('.player-marker.point-scorer').forEach(el => el.classList.remove('point-scorer')); if (!playerId || !playerStats[playerId]) return; const scorerMarker = document.querySelector(`.player-marker[data-player-id="${playerId}"]`); if (scorerMarker) { scorerMarker.classList.add('point-scorer'); pointScorerHighlightTimeout = setTimeout(() => { scorerMarker.classList.remove('point-scorer'); pointScorerHighlightTimeout = null; }, 1500); } }
        function highlightLostPointSide(losingTeamIdSymbol) { if (lostPointHighlightTimeout) clearTimeout(lostPointHighlightTimeout); courtSideAEl.classList.remove('lost-point-highlight'); courtSideBEl.classList.remove('lost-point-highlight'); const targetSideEl = losingTeamIdSymbol === 'A' ? courtSideAEl : courtSideBEl; if (targetSideEl) { targetSideEl.classList.add('lost-point-highlight'); lostPointHighlightTimeout = setTimeout(() => { targetSideEl.classList.remove('lost-point-highlight'); lostPointHighlightTimeout = null; }, 800); } }
        function processEventForStateUpdate(event) {
             let needsRotation = null; let pointScoredBy = null; let scorerPlayerId = null;
             if (event.period && parseInt(event.period) > 0 && parseInt(event.period) !== currentSet) { if (event.code !== 'maali') { currentSet = parseInt(event.period); teamAPoints = 0; teamBPoints = 0; setStartingLineup(currentSet); currentSetStartTime = event.wall_time; } }
             switch (event.code) {
                 case 'aloitajakso': currentSet = parseInt(event.period); teamAPoints = 0; teamBPoints = 0; setStartingLineup(currentSet); servingTeam = null; lastServingTeam = null; currentSetStartTime = event.wall_time; break;
                 case 'aloittavajoukkue': servingTeam = event.team_id === teamAId ? 'A' : 'B'; lastServingTeam = servingTeam; const serverPlayerIdStart = servingTeam === 'A' ? playerPositionsA[1] : playerPositionsB[1]; if (serverPlayerIdStart && playerStats[serverPlayerIdStart]) { playerStats[serverPlayerIdStart].serves++; } break;
                 case 'piste': const scoreMatch = event.description?.match(/(\d+)-(\d+)/); if (scoreMatch) { const currentPointsA = teamAPoints; const currentPointsB = teamBPoints; const newPointsA = parseInt(scoreMatch[1]); const newPointsB = parseInt(scoreMatch[2]); pointScoredBy = (newPointsA > currentPointsA) ? 'A' : 'B'; teamAPoints = newPointsA; teamBPoints = newPointsB; if (event.player_id && String(event.player_id) !== '1') { scorerPlayerId = String(event.player_id); if(playerStats[scorerPlayerId]) { playerStats[scorerPlayerId].points++; } } else { if (pointScoredBy === 'A') teamAImpliedOpponentErrors++; else teamBImpliedOpponentErrors++; } if (servingTeam && pointScoredBy !== servingTeam) { needsRotation = pointScoredBy; } servingTeam = pointScoredBy; if (lastServingTeam === servingTeam && lastServingTeam !== null) { const serverPlayerIdHold = servingTeam === 'A' ? playerPositionsA[1] : playerPositionsB[1]; if (serverPlayerIdHold && playerStats[serverPlayerIdHold]) { playerStats[serverPlayerIdHold].serves++; } } lastServingTeam = servingTeam; } break;
                 case 'maali': const setScoreMatch = event.description?.match(/(\d+)-(\d+)/); if (setScoreMatch) { teamASets = parseInt(setScoreMatch[1]); teamBSets = parseInt(setScoreMatch[2]); } servingTeam = null; lastServingTeam = null; currentSetStartTime = null; break;
                 case 'lopetaottelu': currentSetStartTime = null; break;
             }
             if (needsRotation) { rotateTeam(needsRotation); const serverPlayerIdRotated = needsRotation === 'A' ? playerPositionsA[1] : playerPositionsB[1]; if (serverPlayerIdRotated && playerStats[serverPlayerIdRotated]) { playerStats[serverPlayerIdRotated].serves++; } }
        }
        function displayEvent(index, isRestoring = false) {
             if (!loadedGameData || index < 0 || index >= sortedEvents.length) return;
            const event = sortedEvents[index];
             let scorerPlayerId = null; let lostPointSide = null;
             if (event.code === 'piste') {
                const scoreMatch = event.description?.match(/(\d+)-(\d+)/);
                if (scoreMatch) { const refPointsA = isRestoring ? gameHistory[gameHistory.length-1]?.pointsA : teamAPoints; const refPointsB = isRestoring ? gameHistory[gameHistory.length-1]?.pointsB : teamBPoints; const pointScoredByTeam = (parseInt(scoreMatch[1]) > refPointsA) ? 'A' : 'B'; if (event.player_id && String(event.player_id) !== '1') { scorerPlayerId = String(event.player_id); } else { lostPointSide = pointScoredByTeam === 'A' ? 'B' : 'A'; } }
            }
             if (!isRestoring) { if (currentEventIndex >= 0) { saveState(); } processEventForStateUpdate(event); }
             currentEventIndex = index;
            eventDescEl.textContent = event?.code_fi || event?.code || "Event"; updateScoreboard(); drawCourt(); updateSetElapsedTimeUI(event.wall_time);
            if (!isRestoring) { if (pointScorerHighlightTimeout) clearTimeout(pointScorerHighlightTimeout); document.querySelectorAll('.player-marker.point-scorer').forEach(el => el.classList.remove('point-scorer')); if (lostPointHighlightTimeout) clearTimeout(lostPointHighlightTimeout); courtSideAEl.classList.remove('lost-point-highlight'); courtSideBEl.classList.remove('lost-point-highlight'); if (scorerPlayerId) highlightPointScorer(scorerPlayerId); else if (lostPointSide) highlightLostPointSide(lostPointSide); }
            updateStatsTable();
            const isEnd = currentEventIndex >= sortedEvents.length - 1 || event.code === 'lopetaottelu'; prevEventBtn.disabled = currentEventIndex <= 0; nextEventBtn.disabled = isEnd; playPauseBtn.disabled = isEnd; skipToEndBtn.disabled = isEnd; if (isEnd && isPlaying) { pausePlayback(); }
        }

        document.addEventListener('DOMContentLoaded', () => {
            teamMatchesUrlInput = document.getElementById('team-matches-url'); loadTeamMatchesBtn = document.getElementById('load-team-matches-btn'); teamLoadStatusEl = document.getElementById('team-load-status'); matchListDisplayAreaEl = document.getElementById('match-list-display-area');
            gameUrlInput = document.getElementById('game-url'); loadDataBtn = document.getElementById('load-data-btn'); loadStatusEl = document.getElementById('load-status');
            replayUIContainerEl = document.getElementById('replay-ui-container'); scoreboardEl = document.getElementById('scoreboard'); matchInfoEl = document.getElementById('match-info');
            matchDateEl = document.getElementById('match-date'); matchTimeEl = document.getElementById('match-time'); matchVenueEl = document.getElementById('match-venue'); matchRefereeEl = document.getElementById('match-referee'); matchAttendanceEl = document.getElementById('match-attendance'); setElapsedTimeEl = document.getElementById('set-elapsed-time');
            courtAreaEl = document.getElementById('court-area'); allRalliesDurationChartAreaEl = document.getElementById('all-rallies-duration-chart-area'); allRalliesDurationVisualizationEl = document.getElementById('all-rallies-duration-visualization');
            rallyStatsSummaryAreaEl = document.getElementById('rally-stats-summary-area'); rallyStatsSummaryContentEl = document.getElementById('rally-stats-summary-content');
            playerScoredRalliesDurationChartAreaEl = document.getElementById('player-scored-rallies-duration-chart-area'); playerScoredRalliesDurationVisualizationEl = document.getElementById('player-scored-rallies-duration-visualization');
            playerScoredRallyStatsSummaryAreaEl = document.getElementById('player-scored-rally-stats-summary-area'); playerScoredRallyStatsSummaryContentEl = document.getElementById('player-scored-rally-stats-summary-content');
            statsAreaEl = document.getElementById('stats-area'); setNumberEl = document.getElementById('set-number'); teamANameEl = document.getElementById('team-a-name');
            teamAPointsEl = document.getElementById('team-a-points'); teamASetsEl = document.getElementById('team-a-sets'); teamBNameEl = document.getElementById('team-b-name'); teamBPointsEl = document.getElementById('team-b-points'); teamBSetsEl = document.getElementById('team-b-sets'); eventDescEl = document.getElementById('event-description');
            nextEventBtn = document.getElementById('next-event'); prevEventBtn = document.getElementById('prev-event'); playPauseBtn = document.getElementById('play-pause-btn'); skipToEndBtn = document.getElementById('skip-to-end-btn');
            statsTeamANameEl = document.getElementById('stats-team-a-name'); statsTeamATbody = document.querySelector('#stats-team-a tbody'); statsTeamATfoot = document.querySelector('#stats-team-a tfoot');
            statsTeamBNameEl = document.getElementById('stats-team-b-name'); statsTeamBTbody = document.querySelector('#stats-team-b tbody'); statsTeamBTfoot = document.querySelector('#stats-team-b tfoot');
            courtSideAEl = document.getElementById('court-side-a'); courtSideBEl = document.getElementById('court-side-b');
            toggleAdvancedStatsBtn = document.getElementById('toggle-advanced-stats-btn'); advancedStatsContainerEl = document.getElementById('advanced-stats-container');
            advancedSetSummariesContentEl = document.getElementById('advanced-set-summaries-content'); advancedSideoutContentEl = document.getElementById('advanced-sideout-content'); advancedPointrunsContentEl = document.getElementById('advanced-pointruns-content');
            advancedPlayerPointsSetContentEl = document.getElementById('advanced-player-points-set-content'); advancedLeadChangesMaxLeadsContentEl = document.getElementById('advanced-leadchanges-maxleads-content');
            advancedTimeoutPerformanceContentEl = document.getElementById('advanced-timeout-performance-content'); advancedServingStreaksContentEl = document.getElementById('advanced-serving-streaks-content');
            advancedServeReceivePointsContentEl = document.getElementById('advanced-serve-receive-points-content');
            advancedAvgPointsServiceTurnContentEl = document.getElementById('advanced-avg-points-service-turn-content');
            advancedRotationalPerformanceContentEl = document.getElementById('advanced-rotational-performance-content');

            streakCourtTooltipEl = document.getElementById('streak-court-tooltip');
            streakCourtTooltipContentEl = document.getElementById('streak-court-tooltip-content');
            mainContentContainerEl = document.getElementById('main-content-container');

            // START: Add these lines for AI Analysis
            aiAnalysisContainerEl = document.getElementById('ai-analysis-container');
            openRouterApiKeyInput = document.getElementById('openrouter-api-key');
            generateAiAnalysisBtn = document.getElementById('generate-ai-analysis-btn');
            aiAnalysisStatusEl = document.getElementById('ai-analysis-status');
            aiAnalysisOutputAreaEl = document.getElementById('ai-analysis-output-area');

            // Load saved API key from localStorage
            if (localStorage.getItem('openrouter_api_key')) {
                openRouterApiKeyInput.value = localStorage.getItem('openrouter_api_key');
            }
            // END: Add these lines for AI Analysis

            loadTeamMatchesBtn.addEventListener('click', loadTeamMatches);
            loadDataBtn.addEventListener('click', () => { const url = gameUrlInput.value.trim(); if (url) { loadGameData(url); } else { setStatusMessage(loadStatusEl, 'Please enter a Game Data URL.', 'error'); } });
            playPauseBtn.addEventListener('click', () => { if (isPlaying) { pausePlayback(); } else { playPlayback(); } });
            nextEventBtn.addEventListener('click', () => { pausePlayback(); if (loadedGameData && currentEventIndex < sortedEvents.length - 1) { displayEvent(currentEventIndex + 1, false); } });
            prevEventBtn.addEventListener('click', () => { pausePlayback(); if (loadedGameData && gameHistory.length > 0) { const prevState = gameHistory.pop(); if (prevState) { restoreState(prevState); } } else if (loadedGameData && currentEventIndex > 0){ initializeGame(); } });
            skipToEndBtn.addEventListener('click', () => { if (!loadedGameData || currentEventIndex >= sortedEvents.length - 1) return; pausePlayback(); prevEventBtn.disabled = true; playPauseBtn.disabled = true; nextEventBtn.disabled = true; skipToEndBtn.disabled = true; setStatusMessage(loadStatusEl, 'Calculating final state...', 'loading'); setTimeout(() => { saveState(); for (let i = currentEventIndex + 1; i < sortedEvents.length; i++) { processEventForStateUpdate(sortedEvents[i]); } currentEventIndex = sortedEvents.length - 1; const finalEvent = sortedEvents[currentEventIndex]; eventDescEl.textContent = finalEvent?.code === 'lopetaottelu' ? "Game Finished" : (finalEvent?.code_fi || finalEvent?.code || "Game End"); updateScoreboard(); drawCourt(); updateStatsTable(); updateSetElapsedTimeUI(finalEvent?.wall_time); prevEventBtn.disabled = false; nextEventBtn.disabled = true; playPauseBtn.disabled = true; skipToEndBtn.disabled = true; setStatusMessage(loadStatusEl, 'Skipped to end.', 'success'); setTimeout(() => { if(loadStatusEl.textContent === 'Skipped to end.') loadStatusEl.textContent = '';}, 2000); saveState(); }, 50); });
            toggleAdvancedStatsBtn.addEventListener('click', () => {
                if (advancedStatsContainerEl.style.display === 'none') {
                    if (!advancedStatsRendered && currentGameAdvancedStats) { displayAdvancedGameStats(); }
                    advancedStatsContainerEl.style.display = 'block'; toggleAdvancedStatsBtn.textContent = 'Hide Advanced Game Statistics';
                } else {
                    advancedStatsContainerEl.style.display = 'none'; toggleAdvancedStatsBtn.textContent = 'Show Advanced Game Statistics';
                }
            });
            generateAiAnalysisBtn.addEventListener('click', getAIAnalysis);
            resetUIState(); setStatusMessage(teamLoadStatusEl, 'Enter a team URL to list matches.', 'info'); setStatusMessage(loadStatusEl, 'Enter a game URL or select from a team list.', 'info');

            // --- Automatically load game if match_id is in URL ---
            const urlParams = new URLSearchParams(window.location.search);
            const matchIdFromUrl = urlParams.get('match_id');
            if (matchIdFromUrl) {
                const gameUrl = `${API_BASE_URL}getMatch?match_id=${matchIdFromUrl}`;
                gameUrlInput.value = gameUrl;
                loadGameData(gameUrl);
            }
         });
    </script>
</body>
</html>